// Generated by WBH:Slakefile
/*
// ==UserScript==
// @name WoW Board Helpers
// @description UserScript for the official WoW forum
// @match http://eu.battle.net/wow/fr/forum/*
// @match http://eu.battle.net/wow/en/forum/*
// @match http://us.battle.net/wow/en/forum/*
// @author Tel
// @grant unsafeWindow
// @version 5.2.0
// ==/UserScript==
 * TODO
 *  = See issues : https://github.com/vendethiel/wowboardhelpers/issues
 * changelog
 * 5.4.0
 *  Fix issues
 * 5.3.0
 *  Fix unsafeWindow access on Firefox
 *  Fix key bindings
 *  Fix quick quote
 * 5.2.0
 *  Removed context links from post character infos
 *  Fill back textarea with your answer draft when you change character
 * 5.1.0
 *  Fix topic hiding
 *  Fix char realm display
 * 5.0.0
 *  ______________
 * |              |
 * | NEW FORUMS ! |
 * |______________|
 * 4.3.0
 *  Added next / previous page links
 *  Moved topic jumps to its own folder
 * 4.2.6
 *  Stop triggering update checking if page is not 1
 * 4.2.5
 *  Fix updater
 *  Updater now updates even if there are new messages
 * 4.2.4
 *  Fix limit to 10 memes
 * 4.2.3
 *  Make multi-chars localized
 * 4.2.2
 *  Add <[First Last]> for topic pages
 * 4.2.1
 *  "Jump to page" via "p" bind or expander ("...")
 * 4.2
 *  Stylus as a file with `@import`s rather than `glob`ing a directory
 *  Pin deps
 * 4.1.2
 *  Fix stickies toggling
 *  Add a message for lolchrome
 * 4.1.1
 *  Fix userscript for chrome 27 which breaks our
 *   window reference (FUCK)
 * 4.1
 *  Add a direct link other characters messages
 *  Use correct nephrite extension
 * 4.0.2
 *  Fix keybinds firing with alt ctrl shift
 * 4.0.1
 *  Fix parse-time stupid mistake
 * 4.0
 *  SugarJS, FUCK YOU WORLD; YOLO
 *  Allow for multi-binds
 *  Crabby's dead
 * 3.3.1
 *  Fuck you crabby :)
 * 3.3
 *  MUH COMMONJS
 * 3.2
 *  Fix ALL the reply bugs
 * 3.1.1
 *  Even more perf improvements
 * 3.1
 *  Perf improvements
 * 3.0
 *  Switch to "JadeLS"
 *  End CommonJS-everywhere conversion
 *  Add a jump for new-topic unless banned
 * 2.0.6
 *  Do not remove class when MAR-ing
 * 2.0.5
 *  Improve MAR handling
 * 2.0.4
 *  Fix blizzard titlification
 * 2.0.3
 *  Fix for Firefox
 * 2.0.2
 *  Increase context-links margin
 * 2.0.1
 *  Fix youtube options
 * 2.0.0
 *  Rewrite with CommonJS
 * 1.9.3
 *  Do not autolink CM posts
 * 1.9.2
 *  Added "top" jump
 *  Added "login" jump
 * 1.9.1
 *  Perf improvements
 * 1.9
 *  Fixed a capturing bug with autolink
 *  Fixed a bug, probably creating another one, when the user does not
 *   have enough chars to get the "extended select menu"
 *  Added "HF" link in context links
 * 1.8
 *  Added the CheatSheet
 * 1.7.1
 *  Now the "other characters" list is hidden if bigger than post
 * 1.7
 *  Added `j` as a hotkey for "jump to unread" in topic
 *  Now display recognized alts of people ! (displays link)
 *  Split ALL the code !
 * 1.6.5
 *  post preview is now autolinked too
 *  extended autotitleing to everything in blizzard.net
 *   (everything out is prohibited because of xdomain policy)
 * 1.6.4
 *  Better french headers in ADV mode (takes less space)
 *  Fixed a bug when visiting a thread with #[0-9]+ in the url
 * 1.6.3
 *  Added a fix for blizzard's menu thinking JS has autovivification and shit
 *  Tweaked autolink for accents
 *  Changed ADV styling to please Lord Dryaan (jk he preps in rogue duels)
 * 1.6.2
 *  Now display forum links by their titles rather than their URL
 *  Now display characters by their realm/pseudo rather than their URL
 * 1.6.1
 *  Autolink now works against images too
 *  Rendering should be faster
 * 1.6.0
 *  Added relative time (updated every 10 seconds, should try to calculate when date will be stale)
 *  Make sure we aren't overriding a text in reply rememberer
 *  Checking for updates every 15s
 * 1.5.0
 *  Added the memebox, allowing you to select memes
 * 1.4.0
 *  Added autolink handling edge cases
 *   Also links youtube videos (iframe embedding)
 * 1.3.0
 *  Added `r` as hotkey for "reply"
 * 1.2.2
 *  Better handling of CMs
 * 1.2.1
 *  Redirects are moved at the end (before hidden topics)
 * 1.2
 *  Now allows to hide topics (not stickies),
 *   they'll just get moved to the bottom
 * 1.1
 *  Now automatically saves your textarea on input
 *   and clears saved data on submit
 *  Added an "X" button to clear textarea (+ saved data)
 *  Keeps css formatting, just in case
 * 1.0.1
 *  Now includes jade o/
 * 1.0.0
 *  Made it to the userscript build!
 * 0.8.1
 *  Made it work on chrome, won't override stuff etc
 *  Now uses localStorage for settings (instead of cookies)
 * 0.8
 *  Ability to Mark all as read
 *  Now compares last poster if post-count is somehow wrong
 *  Time is now simplified in ADV mode
 * 0.7
 *  Now hides stickies by default - togglable (stores user pref through cookie)
 * 0.6.2
 *  Disinlined
 *  Bold last poster's name, underline if us
 * 0.6.1
 *  Disabled blizzard's marking
 * 0.6
 *  Finally fixed the bug of "wrong count with deleted posts"
 *   the working solution is just to use .post-lastPost a[href] (ie blabla#354)
 *   This is still not working as intended when there's deleted posts (but that's definitely blizz's fault)
 *  Also splits correctly depending on the language used
 * 0.5
 *  Now adds annotations : [!] for new, [ASCII:check] for read and [?] for never went
 * 0.4
 *  Now works with advanced mode
 *  Fix a bug when logged off
*/
(function(global) {
    function require(file, parentModule) {
        if ({}.hasOwnProperty.call(require.cache, file)) return require.cache[file];
        var resolved = require.resolve(file);
        if (!resolved) throw new Error("Failed to resolve module " + file);
        var module$ = {
            id: file,
            require: require,
            filename: file,
            exports: {},
            loaded: false,
            parent: parentModule,
            children: []
        };
        if (parentModule) parentModule.children.push(module$);
        var dirname = file.slice(0, file.lastIndexOf("/") + 1);
        require.cache[file] = module$.exports;
        resolved.call(module$.exports, module$, module$.exports, dirname, file);
        module$.loaded = true;
        return require.cache[file] = module$.exports;
    }
    require.modules = {};
    require.cache = {};
    require.resolve = function(file) {
        return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
    };
    require.define = function(file, fn) {
        require.modules[file] = fn;
    };
    require.define("/src/wowboardhelpers.ls", function(module, exports, __dirname, __filename) {
        console.log("Ahhhh…greetings ! Want to help on this ? Head over to http://github.com/vendethiel/wowboardhelpers !");
        console.time("wowboardhelpers");
        console.time("WBH: Sugar");
        require("/node_modules/sugar/release/sugar-full.development.js", module);
        Object.extend();
        Date.setLocale(location.href.split("/")[4]);
        console.timeEnd("WBH: Sugar");
        require("/src/board/content-classes.ls", module);
        require("/src/board/css.ls", module);
        require("/src/jumps/index.ls", module);
        require("/src/fix/index.ls", module);
        if (require("/src/topic.ls", module)) {
            require("/src/topic-characters/index.ls", module);
            require("/src/topic-posts/index.ls", module);
            require("/src/topic-layout/index.ls", module);
            require("/src/topic-jumps/index.ls", module);
            if (require("/src/textarea.ls", module)) {
                require("/src/reply/index.ls", module);
            }
        }
        if (require("/src/forum.ls", module)) {
            require("/src/forum-actions/index.ls", module);
            require("/src/forum-layout/index.ls", module);
            require("/src/forum-topics/index.ls", module);
            require("/src/forum-layout/hide-mar.ls", module);
        }
        require("/src/cheatsheet/index.ls", module);
        console.timeEnd("wowboardhelpers");
    });
    require.define("/src/cheatsheet/index.ls", function(module, exports, __dirname, __filename) {
        var cheatsheet, ref$, $, el, possibleDivs, templateCheatsheet, i$, len$, sel, that, x$, ul;
        cheatsheet = require("/src/cheatsheet/bind-key.ls", module).cheatsheet;
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, el = ref$.el;
        if (cheatsheet.size()) {
            possibleDivs = [ ".forum-wrapper", ".forum-actions-bottom" ];
            templateCheatsheet = require("/src/cheatsheet/templates/cheatsheet.ne", module);
            for (i$ = 0, len$ = possibleDivs.length; i$ < len$; ++i$) {
                sel = possibleDivs[i$];
                if (that = $(sel)) {
                    that.appendChild((x$ = el(templateCheatsheet({
                        cheatsheet: cheatsheet
                    })), ul = x$.querySelector("ul"), ul.style.display = "none", x$.querySelector(".toggler").onclick = fn$, 
                    x$));
                    break;
                }
            }
        }
        function fn$(it) {
            ul.style.display = [ "none", "" ].find(function(it) {
                return it !== ul.style.display;
            });
            it.preventDefault();
        }
    });
    require.define("/src/cheatsheet/templates/cheatsheet.ne", function(module, exports, __dirname, __filename) {
        var lang, join;
        lang = require("/lib/lang/index.ls", module);
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            var key, val;
            return '<div id="cheatsheet-container"><!-- that\'s meh but ...--><span class="clear"></span><div id="cheatsheet"><!-- what\'s wrong with you blizz ?--><button class="toggler ui-button button1"><span class="button-left"><span class="button-right">' + (lang.cheatsheet || "") + "</span></span></button><ul>" + (join(function() {
                var ref$, results$ = [];
                for (key in ref$ = locals.cheatsheet) {
                    val = ref$[key];
                    results$.push("<li><b>" + (key || "") + "</b>: " + val + "</li>");
                }
                return results$;
            }()) || "") + "</ul></div></div>";
        };
    });
    require.define("/lib/lang/index.ls", function(module, exports, __dirname, __filename) {
        var l, langs, lang, split$ = "".split;
        l = split$.call(document.location, "/")[4];
        langs = {
            fr: require("/lib/lang/fr.ls", module),
            en: require("/lib/lang/en.ls", module)
        };
        module.exports = lang = function() {
            lang.displayName = "lang";
            var ref$, prototype = lang.prototype, constructor = lang;
            import$(lang, (ref$ = langs[l]) != null ? ref$ : langs.en);
            function lang(it) {
                var ref$;
                return (ref$ = lang[it]) != null ? ref$ : (ref$ = lang[it.camelize(false)]) != null ? ref$ : it;
            }
            lang.pluralize == null && (lang.pluralize = function(count, key) {
                return Math.round(count) + " " + lang(key) + [ count > 1.5 ? "s" : void 8 ];
            });
            lang.singularize == null && (lang.singularize = function(it) {
                if (it[it.length - 1] === "s") {
                    return it.slice(0, -1);
                } else {
                    return it;
                }
            });
            lang.simplifyTime = require("/lib/lang/simplify-time.ls", module);
            lang.locale = l;
            return lang;
        }();
        function import$(obj, src) {
            var own = {}.hasOwnProperty;
            for (var key in src) if (own.call(src, key)) obj[key] = src[key];
            return obj;
        }
    });
    require.define("/lib/lang/simplify-time.ls", function(module, exports, __dirname, __filename) {
        var timeTable;
        timeTable = [ [ "heures", "h" ], [ "heure", "h" ], [ "houres", "h" ], [ "hour", "h" ], [ "minutes", "m" ], [ "minute", "m" ], [ "jours", "j" ], [ "jour", "j" ], [ "days", "d" ], [ "day", "d" ], [ "secondes", "s" ], [ "seconds", "s" ], [ "second", "s" ] ];
        module.exports = function() {
            function simplifyTime(it) {
                var i$, ref$, len$, ref1$, convertFrom, convertTo;
                for (i$ = 0, len$ = (ref$ = timeTable).length; i$ < len$; ++i$) {
                    ref1$ = ref$[i$], convertFrom = ref1$[0], convertTo = ref1$[1];
                    it = it.replace(convertFrom, convertTo);
                }
                return it;
            }
            return simplifyTime;
        }();
    });
    require.define("/lib/lang/en.ls", function(module, exports, __dirname, __filename) {
        module.exports = {
            timeIndex: 0,
            timeOutdex: -1,
            lastMessage: "Last",
            toggleSticky: "Show/Hide stickies",
            mar: "Mark all as read",
            fewSecondsAgo: "few seconds ago",
            newMessages: "There are new message(s)",
            checkingNew: "Checking new messages ...",
            noNew: "No new message.",
            otherCharacters: "Other characters",
            cheatsheet: "Cheatsheet",
            quickQuote: "Quote the selected part",
            jumpToLastRead: "Jump to last read message",
            jumpToPage: "Jump to page",
            jumpToNextPage: "Jump to next page",
            jumpToPrevPage: "Jump to prev page",
            pageNumber: "Page number",
            pageTop: "Go to top",
            pageBottom: "Go to bottom",
            login: "Login",
            newTopic: "New topic",
            pageFirst: "First",
            pageLast: "Last"
        };
    });
    require.define("/lib/lang/fr.ls", function(module, exports, __dirname, __filename) {
        module.exports = {
            timeIndex: 3,
            timeOutdex: 0,
            toggleSticky: "Afficher/Cacher les post-its",
            mar: "Tout marquer comme lu",
            newMessages: "Il y a des nouveau(x) message(s)",
            checkingNew: "Vérification des nouveaux messages ...",
            noNew: "Pas de nouveau message.",
            fewSecondsAgo: "il y a quelques secondes",
            seconde: "second",
            second: "seconde",
            heure: "hour",
            hour: "heure",
            jour: "day",
            day: "jour",
            few: "quelques",
            lastMessage: "Message",
            htmlOverrides: {
                ".replies": "REPS",
                ".poster": "Dernier"
            },
            otherCharacters: "Autres personnages",
            cheatsheet: "Raccourcis",
            quickQuote: "Citer le bout de message sélectionné",
            jumpToLastRead: "Aller au dernier message lu",
            jumpToPage: "Aller à la page",
            jumpToNextPage: "Aller à la page suivante",
            jumpToPrevPage: "Aller à la page précédente",
            pageNumber: "N° de la page",
            pageTop: "Haut de page",
            pageBottom: "Bas de page",
            login: "Connexion",
            newTopic: "Nouveau sujet",
            pageFirst: "Première",
            pageLast: "Dernière"
        };
    });
    require.define("/lib/dom/index.ls", function(module, exports, __dirname, __filename) {
        module.exports = {
            $: require("/lib/dom/$.ls", module),
            $$: require("/lib/dom/$$.ls", module),
            el: require("/lib/dom/el.ls", module),
            node: require("/lib/dom/node.ls", module)
        };
    });
    require.define("/lib/dom/node.ls", function(module, exports, __dirname, __filename) {
        module.exports = function() {
            function node(tag, props) {
                props == null && (props = {});
                return import$(document.createElement(tag), props);
            }
            return node;
        }();
        function import$(obj, src) {
            var own = {}.hasOwnProperty;
            for (var key in src) if (own.call(src, key)) obj[key] = src[key];
            return obj;
        }
    });
    require.define("/lib/dom/el.ls", function(module, exports, __dirname, __filename) {
        module.exports = function(it) {
            var x$, e;
            x$ = document.createElement("div");
            try {
                x$.innerHTML = it;
            } catch (e$) {
                e = e$;
                console.log("failing html", it);
            }
            return x$.firstElementChild;
            return x$;
        };
    });
    require.define("/lib/dom/$$.ls", function(module, exports, __dirname, __filename) {
        module.exports = function(it, ctx) {
            ctx == null && (ctx = document);
            return ctx.querySelectorAll(it);
        };
    });
    require.define("/lib/dom/$.ls", function(module, exports, __dirname, __filename) {
        module.exports = function(it, ctx) {
            ctx == null && (ctx = document);
            return ctx.querySelector(it);
        };
    });
    require.define("/src/cheatsheet/bind-key.ls", function(module, exports, __dirname, __filename) {
        var lang, $, html, body, bindKey, cheatsheet, join$ = [].join;
        lang = require("/lib/lang/index.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        html = $("html");
        body = $("body");
        module.exports = bindKey = function(binds, langKey, cb) {
            var codes;
            cheatsheet[join$.call(binds.toUpperCase().chars(), ", ")] = lang(langKey);
            codes = binds.toUpperCase().codes().map(function(it) {
                return 0 + it;
            });
            document.addEventListener("keydown", function(it) {
                var ref$;
                if (it.altKey || it.ctrlKey || it.shiftKey) {
                    return;
                }
                if (!in$(it.keyCode, codes)) {
                    return;
                }
                if ((ref$ = it.target) !== html && ref$ !== body) {
                    return;
                }
                it.preventDefault();
                cb(it);
            });
        };
        bindKey.cheatsheet = cheatsheet = {};
        function in$(x, xs) {
            var i = -1, l = xs.length >>> 0;
            while (++i < l) if (x === xs[i]) return true;
            return false;
        }
    });
    require.define("/src/forum-topics/index.ls", function(module, exports, __dirname, __filename) {
        var lastUpdated, moveRedirects, hideTopic, times;
        lastUpdated = require("/src/forum-topics/last-updated.ls", module);
        moveRedirects = require("/src/forum-topics/move-redirects.ls", module);
        hideTopic = require("/src/forum-topics/hide-topic.ls", module);
        times = require("/src/forum-topics/times.ls", module);
    });
    require.define("/src/forum-topics/last-updated.ls", function(module, exports, __dirname, __filename) {
        var characters, ref$, $, $$, el, node, templateDefaultPagination, TSTATE_UNK, TSTATE_ALR, TSTATE_CHK, i$, len$, tr, topicTitle, topicId, titleCell, lastPost, lastPostLink, pages, lastPosterName, ref1$, postCount, state, that, split$ = "".split, replace$ = "".replace;
        characters = require("/src/characters.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, $$ = ref$.$$, el = ref$.el, 
        node = ref$.node;
        templateDefaultPagination = require("/src/forum-topics/templates/default-pagination.ne", module);
        TSTATE_UNK = 0;
        TSTATE_ALR = 1;
        TSTATE_CHK = 2;
        for (i$ = 0, len$ = (ref$ = $$(".regular-topic")).length; i$ < len$; ++i$) {
            tr = ref$[i$];
            topicTitle = $(".topic-title", tr);
            topicId = tr.dataset.topicId;
            titleCell = $(".title-cell", tr);
            lastPost = $(".last-post-cell", tr), lastPostLink = lastPost.children[0];
            pages = $(".post-pages-cell", titleCell);
            lastPosterName = $(".author-name", lastPost).innerHTML;
            ref1$ = split$.call(lastPostLink.href, "#"), postCount = ref1$[1];
            if (!pages.querySelector("ul")) {
                pages.innerHTML = templateDefaultPagination({
                    href: lastPostLink.href
                });
            }
            state = checkTopic(topicId, postCount, lastPosterName);
            if (state !== TSTATE_CHK) {
                if (that = characters && lastPosterName) {
                    if (in$(that, characters)) {
                        state = TSTATE_CHK;
                    }
                }
            }
            tr.className = replace$.call(tr.className, /(?:un)?read/, "");
            tr.className += " " + (state === TSTATE_CHK ? ((that = pages.querySelector(".last-read")) && pages.removeChild(that), 
            "read") : "unread");
            if (state !== TSTATE_UNK) {
                topicTitle.href = (ref1$ = pages.getElementsByTagName("a"))[ref1$.length - 1].href;
            }
            markState($(".topic-title", titleCell), state);
        }
        function markState(node, state) {
            var states;
            states = [ "?", "!", "✓" ];
            node.innerHTML = "<b>[" + states[state] + "]</b> " + node.innerHTML;
        }
        function checkTopic(id, count, lastPoster) {
            var ref$;
            switch (ref$ = [ localStorage.getItem("topic_" + id) ], false) {
              case !function(it) {
                    return it > count;
                }(ref$[0]):
                if (lastPoster === getLastPoster(id)) {
                    return TSTATE_CHK;
                } else {
                    return TSTATE_ALR;
                }
                break;

              case !function(it) {
                    return it === count;
                }(ref$[0]):
                return TSTATE_CHK;

              case !(0 === ref$[0] || null === ref$[0]):
                return TSTATE_UNK;

              default:
                return TSTATE_ALR;
            }
        }
        function getLastPoster(it) {
            return localStorage.getItem("topic_lp_" + it);
        }
        function in$(x, xs) {
            var i = -1, l = xs.length >>> 0;
            while (++i < l) if (x === xs[i]) return true;
            return false;
        }
    });
    require.define("/src/forum-topics/templates/default-pagination.ne", function(module, exports, __dirname, __filename) {
        var join;
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return '<div class="pages-wrapper"><ul class="ui-pagination"><li><a data-pagenum=\'1\' rel="np" href="' + locals.href + '">1</a></li></ul></div>';
        };
    });
    require.define("/src/characters.ls", function(module, exports, __dirname, __filename) {
        var $$, characters, slice$ = [].slice;
        $$ = require("/lib/dom/index.ls", module).$$;
        characters = slice$.call($$(".char-wrapper .name"));
        if (characters.length) {
            characters = characters.map("innerHTML");
        }
        module.exports = characters;
    });
    require.define("/src/forum.ls", function(module, exports, __dirname, __filename) {
        var $, that, x$, ref$, ref1$, split$ = "".split;
        $ = require("/lib/dom/index.ls", module).$;
        module.exports = (that = $("#forum-topics")) ? (x$ = that.dataset, ref$ = split$.call(document.location, "?"), 
        x$["url"] = ref$[0], x$["query"] = ref$[1], x$.page = ((ref$ = /\?page=([0-9]+)/.exec(document.location)) != null ? ref$[1] : void 8) || 1, 
        x$.id = (ref1$ = split$.call(that.dataset.url, "/"))[ref1$.length - 2], that) : void 8;
    });
    require.define("/src/reply/index.ls", function(module, exports, __dirname, __filename) {
        var clearTextarea, memebox, preview, quickQuote, rememberReply;
        clearTextarea = require("/src/reply/clear-textarea.ls", module);
        memebox = require("/src/reply/memebox.ls", module);
        preview = require("/src/reply/preview.ls", module);
        quickQuote = require("/src/reply/quick-quote.ls", module);
        rememberReply = require("/src/reply/remember-reply.ls", module);
    });
    require.define("/src/reply/remember-reply.ls", function(module, exports, __dirname, __filename) {
        var textarea, topic, $, submit, w, oldCb;
        textarea = require("/src/textarea.ls", module);
        topic = require("/src/topic.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        submit = $("#new-post [type=submit]");
        if (!textarea.value) {
            textarea.value = localStorage.getItem("post_" + topic.dataset.id) || "";
        }
        textarea.onkeyup = function() {
            return localStorage.setItem("post_" + topic.dataset.id, this.value);
        };
        submit.onclick = function() {
            return localStorage.setItem("post_" + topic.dataset.id, "");
        };
        if (w = require("/src/w.ls", module)) {
            oldCb = w.CharSelect.afterCallback;
            w.CharSelect.afterCallback = function() {
                textarea.value = localStorage.getItem("post_" + topic.dataset.id) || "";
                oldCb();
            };
        }
    });
    require.define("/src/w.ls", function(module, exports, __dirname, __filename) {
        var node, w;
        node = require("/lib/dom/index.ls", module).node;
        w = typeof unsafeWindow != "undefined" && unsafeWindow !== null ? unsafeWindow : window;
        if (!w.Wow) {
            w = void 8;
            console.log("It seems you're using Google Chrome, which is a bad browser and disables some of the features Wow Board Helpers provides.");
            console.log("You may want to try the Injector version of this UserScript, which should resolve your problems.");
        }
        module.exports = w || {};
    });
    require.define("/src/topic.ls", function(module, exports, __dirname, __filename) {
        var $, that, x$, ref$, ref1$, i$, replace$ = "".replace, split$ = "".split;
        $ = require("/lib/dom/index.ls", module).$;
        module.exports = (that = $("#post-list")) ? (that = that.parentNode.parentNode, 
        x$ = that.dataset, x$.url = replace$.call(split$.call(document.location, "?")[0], /#[0-9]+/, ""), 
        x$.page = ((ref$ = /\?page=([0-9]+)/.exec(document.location)) != null ? ref$[1] : void 8) || 1, 
        ref1$ = split$.call(x$.url, "/"), i$ = ref1$.length - 2, x$.topicId = ref1$[i$], 
        x$.id = ref1$[i$ + 1], ref1$, that) : null;
    });
    require.define("/src/textarea.ls", function(module, exports, __dirname, __filename) {
        var topic, $;
        topic = require("/src/topic.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        module.exports = topic ? $("#post-edit textarea") : null;
    });
    require.define("/src/reply/quick-quote.ls", function(module, exports, __dirname, __filename) {
        var bindKey, textarea, w, $;
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        textarea = require("/src/textarea.ls", module);
        w = require("/src/w.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        bindKey("r", "quick-quote", function() {
            var that, ref$;
            if (that = typeof chrome != "undefined" && chrome !== null ? (ref$ = chrome.tabs) != null ? ref$.executeScript : void 8 : void 8) {
                that({
                    code: "window.getSelection().toString()"
                }, function(arg$) {
                    var val;
                    val = arg$[0];
                    return fillQuote(val);
                });
            } else if (that = w != null ? w.getSelection().toString() : void 8) {
                fillQuote(that);
            }
            function fillQuote(it) {
                var x$;
                x$ = textarea;
                x$.value += (x$.value ? "\n" : "") + ("[quote]" + it + "[/quote]");
                x$.selectionStart = x$.selectionEnd = x$.value.length;
                x$.focus();
                return x$;
            }
            $("#forum-actions-bottom").scrollIntoView();
        });
    });
    require.define("/src/reply/preview.ls", function(module, exports, __dirname, __filename) {
        var w, autolink, $, postPreview, old;
        w = require("/src/w.ls", module);
        autolink = require("/lib/autolink/index.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        postPreview = $("#post-preview");
        if ((w != null ? w.BML : void 8) != null) {
            old = bind$(w.BML, "preview");
            w.BML.preview = function(content, target, callback) {
                old(content, target, function() {
                    callback();
                    autolink(postPreview);
                });
            };
        }
        function bind$(obj, key, target) {
            return function() {
                return (target || obj)[key].apply(obj, arguments);
            };
        }
    });
    require.define("/lib/autolink/index.ls", function(module, exports, __dirname, __filename) {
        var extensions, rules, ajax, replace$ = "".replace;
        extensions = "(?:com|net|org|eu|fr|jp|us|co.uk|me)";
        rules = [ [ /(?:https?:\/\/)?(?:(?:www|m)\.)?(youtu\.be\/([\w\-_]+)(\?[&=\w\-_;\#]*)?|youtube\.com\/watch\?([&=\w\-_;\.\?\#\%]*)v=([\w\-_]+)([&=\w\-\._;\?\#\%]*))/g, '<iframe class="youtube-player" type="text/html" width="640" height="385" src="http://www.youtube.com/embed/$2$5#$3$4$6" frameborder="0"></iframe>' ], [ /\((https?:\/\/)([^<\s\)]+)\)/g, '(<a class="external" rel="noreferrer" href="$1$2" title="$1$2" data-autolink="paren-specialcase" target="_blank">$2</a>)' ], [ RegExp("(^|>|;|\\s)(?:https?:\\/\\/)?([\\w\\.\\-]+\\." + extensions + "(/[^<\\s]*)?(?=[\\s<]|$))", "g"), '$1<a class="external" rel="noreferrer" href="http://$2" data-autolink="protocol-specialcase" title="$2" target="_blank">$2</a>' ], [ /([^"'\/]|^)(https?:\/\/)(?![a-z]{2}\.battle\.net)([^<\s\)]+)/g, '$1<a class="external" rel="noreferrer" href="$2$3" title="$2$3" data-autolink="quote-specialcase" target="_blank">$3</a>' ], [ RegExp("(^|>|;|\\s)((?!(?:www\\.)?dropbox)[\\w\\.\\-]+\\." + extensions + "(/[^.<\\s]*)\\.(jpg|png|gif|jpeg)(?=[\\s<]|$)|puu\\.sh/[a-zA-Z0-9]+)", "g"), '$1<img src="http://$2" alt="$2" class="autolink" />' ] ];
        module.exports = elAutolink;
        ajax = require("/lib/ajax/index.ls", module);
        function elAutolink(el) {
            var h, r, ref$, url, e;
            try {
                h = autolink(el.innerHTML);
                r = /\>((?:http:\/\/)?[a-z]{2}\.battle\.net\/[^<\s.]*)/g;
                while ((ref$ = r.exec(h)) != null && (url = ref$[1], ref$)) {
                    fn$.call(this, url);
                }
                return el.innerHTML = h;
            } catch (e$) {
                e = e$;
                return console.log("Unable to generate valid HTML : " + h + " (" + e + ")");
            }
            function fn$(url) {
                var fullUrl;
                fullUrl = url.has("http://") ? url : "http://" + url;
                ajax.get(fullUrl, function() {
                    var that;
                    if (that = /<title>(.+)<\/title>/.exec(this.response)) {
                        el.innerHTML = el.innerHTML.replace(">" + url, ">" + replace$.call(that[1], " - World of Warcraft", ""));
                    }
                });
            }
        }
        function autolink(it) {
            var i$, ref$, len$, ref1$, pattern, replacement;
            for (i$ = 0, len$ = (ref$ = rules).length; i$ < len$; ++i$) {
                ref1$ = ref$[i$], pattern = ref1$[0], replacement = ref1$[1];
                it = it.replace(pattern, replacement);
            }
            return it;
        }
    });
    require.define("/lib/ajax/index.ls", function(module, exports, __dirname, __filename) {
        module.exports = {
            get: function(url, success) {
                var x$;
                x$ = new XMLHttpRequest();
                x$.open("GET", url);
                x$.onload = success;
                x$.send();
                return x$;
            }
        };
    });
    require.define("/src/reply/memebox.ls", function(module, exports, __dirname, __filename) {
        var memes, textarea, ref$, $, el, templateMemebox, that, addMeme, appendMeme, memebox, ul, replace$ = "".replace;
        memes = {
            challengeaccepted: "http://sambacentral.files.wordpress.com/2012/11/challenge-accepted.jpg",
            foreveralone: "http://i1.kym-cdn.com/entries/icons/original/000/003/619/Untitled-1.jpg",
            bitchplease: "http://www.troll.me/images/yao-ming/bitch-please.jpg",
            stfuandgtfo: "http://4.bp.blogspot.com/-cD0QmZLGuAY/TnHyAD269EI/AAAAAAAAAkU/6O4rA1REcdI/s1600/STFU_and_GTFO.jpg",
            youdontsay: "http://bearsharkaxe.com/wp-content/uploads/2012/06/you-dont-say.jpg",
            fullretard: "http://www.osborneink.com/wp-content/uploads/2012/11/never_go_full_retard1.jpg",
            susalenemi: "http://img11.hostingpics.net/pics/311549libertlolxqt.png",
            fulloffuck: "http://www.mememaker.net/static/images/templates/14288.jpg",
            seriously: "http://i3.kym-cdn.com/entries/icons/original/000/005/545/OpoQQ.jpg",
            trollface: "http://fc09.deviantart.net/fs70/f/2012/342/5/a/troll_face_by_bmsproductionz-d5ng9k6.png",
            escalated: "http://cdn.memegenerator.net/instances/250x250/30199807.jpg",
            fuckyeah: "http://cdn.ebaumsworld.com/mediaFiles/picture/2168064/82942867.jpg",
            pedobear: "http://aserres.free.fr/pedobear/pedobear.png",
            slowpoke: "https://0-media-cdn.foolz.us/ffuuka/board/a/image/1351/43/1351437155488.png",
            megusta: "http://a400.idata.over-blog.com/5/08/51/37/me_gusta_by_projectendo-d2z3rku.jpg",
            notbad: "http://www.reactionface.info/sites/default/files/images/YvEN9.png",
            ohcrap: "http://i1.kym-cdn.com/entries/icons/original/000/004/077/Raisins_Face.jpg",
            trauma: "http://global3.memecdn.com/trauma_c_629591.jpg",
            yuno: "http://i1.kym-cdn.com/entries/icons/original/000/004/006/y-u-no-guy.jpg",
            okay: "http://cache.ohinternet.com/images/e/e6/Okay_guy.jpg",
            no: "http://stickerish.com/wp-content/uploads/2011/09/NoGuyBlackSS.png"
        };
        textarea = require("/src/textarea.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, el = ref$.el;
        templateMemebox = require("/src/reply/templates/memebox.ne", module);
        if (that = $(".post.general")) {
            that.removeChild((ref$ = that.children)[ref$.length - 1]);
            addMeme = function(url) {
                return function() {
                    return textarea.value += [ textarea.value ? "\n" : void 8 ] + url;
                };
            };
            appendMeme = function(name, url) {
                var x$;
                return ul.appendChild((x$ = document.createElement("li"), x$.innerHTML = name, x$.onclick = addMeme(url), 
                x$));
            };
            memebox = el(templateMemebox());
            ul = memebox.querySelector("#memes");
            memebox.querySelector("#meme-search").onkeyup = function() {
                var value, approximates, i, name, ref$, url, i$, len$;
                value = replace$.call(this.value, /[\s_-]+/, "");
                ul.innerHTML = "";
                if (!value) {
                    return;
                }
                approximates = [];
                i = 0;
                meme: for (name in ref$ = memes) {
                    url = ref$[name];
                    switch (name.indexOf(value)) {
                      case -1:
                        break;

                      case 0:
                        appendMeme(name, url);
                        if (++i > 10) {
                            break meme;
                        }
                        break;

                      default:
                        approximates.push([ name, url ]);
                    }
                }
                for (i$ = 0, len$ = approximates.length; i$ < len$; ++i$) {
                    ref$ = approximates[i$], name = ref$[0], url = ref$[1];
                    appendMeme(name, url);
                    if (++i > 10) {
                        break;
                    }
                }
            };
            that.appendChild(memebox);
        }
    });
    require.define("/src/reply/templates/memebox.ne", function(module, exports, __dirname, __filename) {
        var join;
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return '<div id="memebox"><h1>MemeBox</h1><br/><input id="meme-search" placeholder="meme" autocomplete="off" size="15"/><ul id="memes"></ul></div>';
        };
    });
    require.define("/src/reply/clear-textarea.ls", function(module, exports, __dirname, __filename) {
        var textarea, topic, ref$, $, el, templateClearTextarea, clearer, that;
        textarea = require("/src/textarea.ls", module);
        topic = require("/src/topic.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, el = ref$.el;
        templateClearTextarea = require("/src/reply/templates/clear-textarea.ne", module);
        clearer = el(templateClearTextarea());
        if (that = $(".editor1")) {
            that.insertBefore(clearer, textarea);
            clearer.onclick = function() {
                textarea.value = "";
                localStorage.removeItem("post_" + topic.dataset.id);
            };
        }
    });
    require.define("/src/reply/templates/clear-textarea.ne", function(module, exports, __dirname, __filename) {
        var join;
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return '<div class="clear-textarea">X</div>';
        };
    });
    require.define("/src/topic-jumps/index.ls", function(module, exports, __dirname, __filename) {
        var unread, pageNav;
        unread = require("/src/topic-jumps/unread.ls", module);
        pageNav = require("/src/topic-jumps/page-nav.ls", module);
    });
    require.define("/src/topic-jumps/page-nav.ls", function(module, exports, __dirname, __filename) {
        var topic, bindKey, $, curPage;
        topic = require("/src/topic.ls", module);
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        curPage = $(".ui-pagination li.current");
        if (curPage != null && curPage.previousElementSibling) {
            bindKey("aq", "jump-to-prev-page", function() {
                var ref$, page, url;
                ref$ = topic.dataset, page = ref$.page, url = ref$.url;
                document.location = url + "?page=" + --page;
            });
        }
        if (curPage != null && curPage.nextElementSibling) {
            bindKey("ed", "jump-to-next-page", function() {
                var ref$, page, url;
                ref$ = topic.dataset, page = ref$.page, url = ref$.url;
                document.location = url + "?page=" + ++page;
            });
        }
    });
    require.define("/src/topic-jumps/unread.ls", function(module, exports, __dirname, __filename) {
        var topic, bindKey, $, lastPostId;
        topic = require("/src/topic.ls", module);
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        if (lastPostId = localStorage.getItem("topic_" + topic.dataset.id)) {
            bindKey("jf", "jump-to-last-read", function() {
                var lastPostPage, ref$;
                lastPostPage = Math.ceil(lastPostId / 20);
                if (topic.dataset.page < lastPostPage) {
                    document.location = topic.dataset.url + ("?page=" + lastPostPage);
                } else {
                    if ((ref$ = $(".post-info .post-info-wrapper .post-index[href='#" + lastPostId + "'")) != null) {
                        ref$.scrollIntoView();
                    }
                }
            });
        }
    });
    require.define("/src/topic-layout/index.ls", function(module, exports, __dirname, __filename) {
        var pagination;
        pagination = require("/src/topic-layout/pagination.ls", module);
    });
    require.define("/src/topic-layout/pagination.ls", function(module, exports, __dirname, __filename) {
        var $$, templatePagination, topic, ref$, page, url, uls, ul, pagination, paginationHtml, i$, x$, len$;
        $$ = require("/lib/dom/index.ls", module).$$;
        templatePagination = require("/src/topic-layout/templates/pagination.ne", module);
        topic = require("/src/topic.ls", module);
        ref$ = topic.dataset, page = ref$.page, url = ref$.url;
        uls = $$("ul.ui-pagination");
        if (uls.length) {
            ul = uls[0], pagination = ul.innerHTML;
            paginationHtml = templatePagination({
                page: page,
                url: url,
                pagination: pagination,
                max: +(ref$ = $$("li:not(.cap-item) span", ul))[ref$.length - 1].innerHTML
            });
            for (i$ = 0, len$ = uls.length; i$ < len$; ++i$) {
                x$ = uls[i$];
                x$.innerHTML = paginationHtml;
            }
        }
    });
    require.define("/src/topic-layout/templates/pagination.ne", function(module, exports, __dirname, __filename) {
        var lang, join;
        lang = require("/lib/lang/index.ls", module);
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return "    " + ((locals.page > 2 ? '<li class="cap-item"><a href="' + locals.url + '?page=1">' + lang.pageFirst + "</a></li>" : void 8) || "") + "\n" + (locals.pagination || "") + "\n" + ((locals.max - locals.page > 2 ? '<li class="cap-item"><a href="' + locals.url + "?page=" + locals.max + '">' + lang.pageLast + "</a></li>" : void 8) || "");
        };
    });
    require.define("/src/topic-posts/index.ls", function(module, exports, __dirname, __filename) {
        var autolink, updateCount;
        autolink = require("/src/topic-posts/autolink.ls", module);
        updateCount = require("/src/topic-posts/update-count.ls", module);
    });
    require.define("/src/topic-posts/update-count.ls", function(module, exports, __dirname, __filename) {
        var topic, $$, pages, postCount, ref$, lastPosterName;
        topic = require("/src/topic.ls", module);
        $$ = require("/lib/dom/index.ls", module).$$;
        pages = $$("#forum-actions-top .ui-pagination li:not(.cap-item)");
        if (pages && needUpdate()) {
            postCount = (ref$ = topic.getElementsByClassName("post-info"))[ref$.length - 1].getElementsByTagName("a")[0].getAttribute("href").from(1);
            lastPosterName = (ref$ = $$(".poster-name", topic))[ref$.length - 1].innerHTML.trim();
            localStorage.setItem("topic_" + topic.dataset.id, postCount);
            localStorage.setItem("topic_lp_" + topic.dataset.id, lastPosterName);
        }
        function needUpdate() {
            return !pages.length || pages.length && "current" === pages[pages.length - 1].className || !localStorage.getItem("topic_" + topic.dataset.id);
        }
    });
    require.define("/src/topic-posts/autolink.ls", function(module, exports, __dirname, __filename) {
        var autolink, $$, i$, ref$, len$, post;
        autolink = require("/lib/autolink/index.ls", module);
        $$ = require("/lib/dom/index.ls", module).$$;
        for (i$ = 0, len$ = (ref$ = $$(".post-detail")).length; i$ < len$; ++i$) {
            post = ref$[i$];
            if (post.parentNode.parentNode.parentNode.parentNode.parentNode.classList.contains("blizzard")) {
                continue;
            }
            autolink(post);
        }
    });
    require.define("/src/topic-characters/index.ls", function(module, exports, __dirname, __filename) {
        var contextLinks, realm, multiChars;
        contextLinks = require("/src/topic-characters/context-links.ls", module);
        realm = require("/src/topic-characters/realm.ls", module);
        multiChars = require("/src/topic-characters/multi-chars.ls", module);
    });
    require.define("/src/topic-characters/multi-chars.ls", function(module, exports, __dirname, __filename) {
        var lang, ref$, $, $$, el, templateMultiChars, that, accountCharacters, modified, i$, len$, postCharacter, iconIgnore, link, ref1$, account, current, characters, postDetail, height, toggle, ul, children, limit, replace$ = "".replace, slice$ = [].slice;
        lang = require("/lib/lang/index.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, $$ = ref$.$$, el = ref$.el;
        templateMultiChars = require("/src/topic-characters/templates/multi-chars.ne", module);
        if (that = (ref$ = localStorage.accountCharacters, delete localStorage.accountCharacters, 
        ref$)) {
            localStorage.setItem(lang.locale + "-accountCharacters", that);
        }
        accountCharacters = (that = localStorage.getItem(lang.locale + "-accountCharacters")) ? JSON.parse(that) : {};
        function clean(it) {
            it = replace$.call(it, "context-link", "");
            it = replace$.call(it, 'xmlns="http://www.w3.org/1999/xhtml" ', "");
            return it;
        }
        modified = false;
        for (i$ = 0, len$ = (ref$ = $$(".post-character")).length; i$ < len$; ++i$) {
            postCharacter = ref$[i$];
            iconIgnore = postCharacter.querySelector(".icon-ignore");
            if (!iconIgnore) {
                continue;
            }
            link = clean(postCharacter.querySelector(".bnet-username > a").outerHTML.trim());
            ref1$ = /ignoreUser\(this, ([0-9]+)/.exec(iconIgnore.getAttribute("onclick").toString()), 
            account = ref1$[1];
            ref1$ = postCharacter.dataset;
            ref1$.account = account;
            ref1$.link = link;
            if (!in$(link, accountCharacters[account] || (accountCharacters[account] = []))) {
                modified = true;
                accountCharacters[account].push(link);
            }
        }
        if (modified) {
            localStorage.setItem(lang.locale + "-accountCharacters", JSON.stringify(accountCharacters));
        }
        for (i$ = 0, len$ = (ref$ = $$(".topic-post:not(.hidden) .post-character")).length; i$ < len$; ++i$) {
            postCharacter = ref$[i$];
            ref1$ = postCharacter.dataset, account = ref1$.account, current = ref1$.link;
            if (!account) {
                continue;
            }
            characters = accountCharacters[account].exclude(null);
            if (characters.length === 1) {
                continue;
            }
            postDetail = $(".post-detail", postCharacter.parentNode), height = postDetail.offsetHeight;
            toggle = characters.length > 2 && height < 130 + (characters.length - 1) * 15;
            postCharacter.appendChild(el(templateMultiChars({
                toggle: toggle,
                current: current,
                characters: characters
            })));
            if (toggle) {
                ul = postCharacter.querySelector("ul"), children = ul.children;
                children = slice$.call(children);
                if ((limit = ((height - 130) / 15).floor()) > 1) {
                    children.to(limit).each(fn$);
                }
                toggle = $(".toggle", postCharacter);
                fn1$.call(this, ul, children, toggle);
            }
        }
        function in$(x, xs) {
            var i = -1, l = xs.length >>> 0;
            while (++i < l) if (x === xs[i]) return true;
            return false;
        }
        function fn$(it) {
            return it.style.display = "";
        }
        function fn1$(ul, children, toggle) {
            toggle.onclick = function() {
                children.each(function(it) {
                    return it.style.display = "";
                });
                postCharacter.querySelector(".toggler").style.display = "none";
                return toggle.onclick = function() {};
            };
        }
    });
    require.define("/src/topic-characters/templates/multi-chars.ne", function(module, exports, __dirname, __filename) {
        var lang, postsOf, join, join$ = [].join;
        lang = require("/lib/lang/index.ls", module);
        postsOf = function(it) {
            var name, ref$;
            name = [ (ref$ = it.split("/"))[5], ref$[4] ];
            name[1] = name[1].humanize();
            return "http://eu.battle.net/wow/fr/search?f=post&amp;a=" + join$.call(name, "%40") + "&amp;sort=time";
        };
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            var character;
            return '    <div id="account-characters"><h1 class="toggle">' + (lang("otherCharacters") || "") + "\n" + ((locals.toggle ? '<span class="toggler">' + (" [+]" || "") + "</span>" : void 8) || "") + "</h1><br/><ul>" + (join(function() {
                var i$, ref$, len$, results$ = [];
                for (i$ = 0, len$ = (ref$ = locals.characters.exclude(locals.current)).length; i$ < len$; ++i$) {
                    character = ref$[i$];
                    results$.push('<li style="' + [ locals.toggle ? "display: none" : void 8 ] + '">' + (character || "") + '<a href="' + postsOf(character) + '" class="see-messages"></a></li>');
                }
                return results$;
            }()) || "") + "</ul></div>";
        };
    });
    require.define("/src/topic-characters/realm.ls", function(module, exports, __dirname, __filename) {
        var $$, i$, ref$, len$, infos, link, ref1$, ref2$, realm, split$ = "".split;
        $$ = require("/lib/dom/index.ls", module).$$;
        for (i$ = 0, len$ = (ref$ = $$(".user-details")).length; i$ < len$; ++i$) {
            infos = ref$[i$];
            link = (ref1$ = infos.querySelector(".icon-profile.link-first")) != null ? ref1$.getAttribute("href") : void 8;
            if (!link) {
                continue;
            }
            if (link.has("//")) {
                continue;
            }
            ref2$ = split$.call(link, "/"), realm = ref2$[4];
            realm = realm.replace("-", " ").capitalize(true).replace(" ", "-");
            if ((ref2$ = infos.querySelector(".character-desc")) != null) {
                ref2$.innerHTML += "<br />" + realm;
            }
        }
    });
    require.define("/src/topic-characters/context-links.ls", function(module, exports, __dirname, __filename) {
        var topic, el, templateContextLinks, i$, ref$, len$, context, extraContext;
        topic = require("/src/topic.ls", module);
        el = require("/lib/dom/index.ls", module).el;
        templateContextLinks = require("/src/topic-characters/templates/context-links.ne", module);
        for (i$ = 0, len$ = (ref$ = topic.querySelectorAll("#post-list .context-links")).length; i$ < len$; ++i$) {
            context = ref$[i$];
            if (context.children.length === 1) {
                continue;
            }
            extraContext = el(templateContextLinks({
                link: context.children[0].href
            }));
            context.insertBefore(extraContext, context.querySelector(".link-last"));
        }
    });
    require.define("/src/topic-characters/templates/context-links.ne", function(module, exports, __dirname, __filename) {
        var join;
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return '<span class="extra-links"><a href="' + locals.link + 'achievement" class="link-first extra-link">HF</a><a href="' + locals.link + 'statistic#21:152" class="link-first extra-link">PvP</a></span>';
        };
    });
    require.define("/src/fix/index.ls", function(module, exports, __dirname, __filename) {
        var htmlOverrides, menu;
        htmlOverrides = require("/src/fix/html-overrides.ls", module);
        menu = require("/src/fix/menu.ls", module);
    });
    require.define("/src/fix/menu.ls", function(module, exports, __dirname, __filename) {
        var w, old;
        w = require("/src/w.ls", module);
        if ((w != null ? w.Menu : void 8) != null) {
            old = w.Menu.show;
            w.Menu.show = function(arg$, arg1$, options) {
                var ref$, key$, ref1$;
                options == null && (options = {});
                (ref$ = w.Menu.dataIndex)[key$ = (ref1$ = options.set) != null ? ref1$ : "base"] == null && (ref$[key$] = []);
                return old.apply(this, arguments);
            };
        }
    });
    require.define("/src/fix/html-overrides.ls", function(module, exports, __dirname, __filename) {
        var lang, $, that, k, v, ref$;
        lang = require("/lib/lang/index.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        if (that = lang.htmlOverrides) {
            for (k in that) {
                v = that[k];
                if ((ref$ = $(k)) != null) {
                    ref$.innerHTML = v;
                }
            }
        }
    });
    require.define("/src/jumps/index.ls", function(module, exports, __dirname, __filename) {
        var $;
        $ = require("/lib/dom/index.ls", module).$;
        require("/src/jumps/top.ls", module);
        if (!$(".player-name")) {
            require("/src/jumps/login.ls", module);
        }
    });
    require.define("/src/jumps/login.ls", function(module, exports, __dirname, __filename) {
        var bindKey, w;
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        w = require("/src/w.ls", module);
        if (w.Login) {
            bindKey("l", "login", function() {
                w.Login.open("https://eu.battle.net/login/login.frag");
            });
        }
    });
    require.define("/src/jumps/top.ls", function(module, exports, __dirname, __filename) {
        var bindKey, $;
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        bindKey("t", "page-top", function() {
            $("#logo").scrollIntoView();
        });
    });
    require.define("/src/board/css.ls", function(module, exports, __dirname, __filename) {
        var node, style;
        node = require("/lib/dom/index.ls", module).node;
        style = node("style", {
            type: "text/css",
            innerHTML: "/*slake:build#compile-ls embeds css*/\n/**\
 * Wow Board Helpers Stylesheet file\
 */\
.view-topic .post-detail {\
  font-size: 12px !important;\
}\
#forum-actions-top h1 {\
  text-align: center;\
  margin-left: 200px;\
}\
.forum .forum-actions {\
  padding: 0px;\
}\
.forum .actions-panel {\
  margin-right: 15px;\
}\
.forum .forum-options {\
  float: right;\
  right: auto;\
  position: relative;\
  margin-top: 25px;\
  margin-right: 15px;\
}\
.forum .forum-options a {\
  display: block;\
  background: url(\"http://eu.battle.net/wow/static/images/buttons/button-1.png\") no-repeat;\
  background-position: 100% -123px;\
  height: 20px;\
  padding: 0 28px 0 0;\
}\
.poster {\
  font-weight: bold;\
}\
.own-poster {\
  text-decoration: underline;\
}\
a.show-topic {\
  cursor: pointer;\
  float: left;\
  margin-top: 13px;\
  color: #008000;\
}\
a.show-topic:hover {\
  color: #008000 !important;\
}\
a.hide-topic {\
  cursor: pointer;\
  float: left;\
  margin-top: 13px;\
  color: #f00;\
}\
a.hide-topic:hover {\
  color: #f00 !important;\
}\
.last-read {\
  opacity: 0;\
}\
tr:hover .last-read {\
  opacity: 1;\
}\
.view-forum .forum-topics .post-pages-cell .last-read-page .last-read-arrow {\
  display: none;\
}\
.view-forum .forum-topics .post-pages-cell .pages-wrapper {\
  display: inline;\
}\
.view-forum .forum-topics .post-pages-cell .ui-pagination {\
  background: none;\
}\
#account-characters {\
  margin-top: 10px;\
  margin-left: 30px;\
}\
#account-characters h1 {\
  display: inline;\
}\
#account-characters ul {\
  list-style: circle;\
  margin-left: 20px;\
}\
#account-characters a {\
  font-weight: bold;\
}\
#account-characters .see-messages {\
  background-image: url(\"http://eu.battle.net/wow/static/images/icons/context.gif\");\
  background-position: 0 -30px;\
  display: inline-block;\
  margin-bottom: -10px;\
  width: 30px;\
  height: 30px;\
}\
.context-links .extra-link {\
  background-image: none !important;\
  padding-left: 8px !important;\
  border-top-left-radius: 0px !important;\
  border-bottom-left-radius: 0px !important;\
}\
.ui-context {\
  width: 240px !important;\
}\
.karma {\
  white-space: normal !important;\
}\
.post-user .avatar {\
  top: 27px !important;\
}\
img.autolink {\
  border: 5px solid #000;\
  max-width: 540px;\
  max-height: 500px;\
}\
.logged-off .karma {\
  display: none;\
}\
.view-topic .forum-actions-bottom {\
  height: 50px;\
}\
.view-topic .forum-actions-bottom .ui-pagination {\
  margin-top: 35px;\
}\
.rate-post-wrapper .rate-option {\
  display: inline-block;\
  margin: 0 0 0 0;\
}\
.clear-textarea {\
  display: block;\
  margin: 1px 0 1px 553px;\
  font-weight: bold;\
  font-size: 2em;\
  position: absolute;\
  z-index: 2;\
  cursor: pointer;\
}\
#memebox {\
  position: relative;\
  float: right;\
  width: 150px;\
  top: 5px;\
}\
#memebox h1 {\
  font-size: 1.8em;\
  display: inline;\
}\
#memebox .hider {\
  color: #f00;\
  display: none;\
}\
#memebox:hover .hider {\
  display: inline;\
}\
#memebox .unhider {\
  color: #008000;\
  display: none;\
}\
#memebox:hover .unhider {\
  display: inline;\
}\
#memebox ul#memes {\
  margin-top: 10px;\
  margin-left: 30px;\
  list-style-type: circle;\
}\
#memebox li {\
  font-weight: bold;\
  color: link;\
  text-decoration: underline;\
}\
.topic-form .topic-form-wrapper .post-editor #detail {\
  font: normal 12px/1.5 Arial, Verdana, sans-serif;\
}"
        });
        document.head.appendChild(style);
    });
    require.define("/src/board/content-classes.ls", function(module, exports, __dirname, __filename) {
        var topic, forum, $, content, classes, join$ = [].join;
        topic = require("/src/topic.ls", module);
        forum = require("/src/forum.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        content = $("#content");
        classes = [];
        classes.push(function() {
            switch (false) {
              case !topic:
                return "topic";

              case !forum:
                return "forum";

              default:
                return "";
            }
        }());
        classes.push($(".login-msg") ? "logged-off" : "logged-in");
        content.className = join$.call(classes, " ");
    });
    require.define("/node_modules/sugar/release/sugar-full.development.js", function(module, exports, __dirname, __filename) {
        (function() {
            "use strict";
            var object = Object, array = Array, regexp = RegExp, date = Date, string = String, number = Number, math = Math, Undefined;
            var globalContext = typeof global !== "undefined" ? global : this;
            var internalToString = object.prototype.toString;
            var internalHasOwnProperty = object.prototype.hasOwnProperty;
            var definePropertySupport = object.defineProperty && object.defineProperties;
            var regexIsFunction = typeof regexp() === "function";
            var noKeysInStringObjects = !("0" in new string("a"));
            var typeChecks = {};
            var matchedByValueReg = /^\[object Date|Array|String|Number|RegExp|Boolean|Arguments\]$/;
            var ClassNames = "Boolean,Number,String,Array,Date,RegExp,Function".split(",");
            var isBoolean = buildPrimitiveClassCheck("boolean", ClassNames[0]);
            var isNumber = buildPrimitiveClassCheck("number", ClassNames[1]);
            var isString = buildPrimitiveClassCheck("string", ClassNames[2]);
            var isArray = buildClassCheck(ClassNames[3]);
            var isDate = buildClassCheck(ClassNames[4]);
            var isRegExp = buildClassCheck(ClassNames[5]);
            var isFunction = buildClassCheck(ClassNames[6]);
            function isClass(obj, klass, cached) {
                var k = cached || className(obj);
                return k === "[object " + klass + "]";
            }
            function buildClassCheck(klass) {
                var fn = klass === "Array" && array.isArray || function(obj, cached) {
                    return isClass(obj, klass, cached);
                };
                typeChecks[klass] = fn;
                return fn;
            }
            function buildPrimitiveClassCheck(type, klass) {
                var fn = function(obj) {
                    if (isObjectType(obj)) {
                        return isClass(obj, klass);
                    }
                    return typeof obj === type;
                };
                typeChecks[klass] = fn;
                return fn;
            }
            function className(obj) {
                return internalToString.call(obj);
            }
            function initializeClasses() {
                initializeClass(object);
                iterateOverObject(ClassNames, function(i, name) {
                    initializeClass(globalContext[name]);
                });
            }
            function initializeClass(klass) {
                if (klass["SugarMethods"]) return;
                defineProperty(klass, "SugarMethods", {});
                extend(klass, false, true, {
                    extend: function(methods, override, instance) {
                        extend(klass, instance !== false, override, methods);
                    },
                    sugarRestore: function() {
                        return batchMethodExecute(this, klass, arguments, function(target, name, m) {
                            defineProperty(target, name, m.method);
                        });
                    },
                    sugarRevert: function() {
                        return batchMethodExecute(this, klass, arguments, function(target, name, m) {
                            if (m["existed"]) {
                                defineProperty(target, name, m["original"]);
                            } else {
                                delete target[name];
                            }
                        });
                    }
                });
            }
            function extend(klass, instance, override, methods) {
                var extendee = instance ? klass.prototype : klass;
                initializeClass(klass);
                iterateOverObject(methods, function(name, extendedFn) {
                    var nativeFn = extendee[name], existed = hasOwnProperty(extendee, name);
                    if (isFunction(override) && nativeFn) {
                        extendedFn = wrapNative(nativeFn, extendedFn, override);
                    }
                    if (override !== false || !nativeFn) {
                        defineProperty(extendee, name, extendedFn);
                    }
                    klass["SugarMethods"][name] = {
                        method: extendedFn,
                        existed: existed,
                        original: nativeFn,
                        instance: instance
                    };
                });
            }
            function extendSimilar(klass, instance, override, set, fn) {
                var methods = {};
                set = isString(set) ? set.split(",") : set;
                set.forEach(function(name, i) {
                    fn(methods, name, i);
                });
                extend(klass, instance, override, methods);
            }
            function batchMethodExecute(target, klass, args, fn) {
                var all = args.length === 0, methods = multiArgs(args), changed = false;
                iterateOverObject(klass["SugarMethods"], function(name, m) {
                    if (all || methods.indexOf(name) !== -1) {
                        changed = true;
                        fn(m["instance"] ? target.prototype : target, name, m);
                    }
                });
                return changed;
            }
            function wrapNative(nativeFn, extendedFn, condition) {
                return function(a) {
                    return condition.apply(this, arguments) ? extendedFn.apply(this, arguments) : nativeFn.apply(this, arguments);
                };
            }
            function defineProperty(target, name, method) {
                if (definePropertySupport) {
                    object.defineProperty(target, name, {
                        value: method,
                        configurable: true,
                        enumerable: false,
                        writable: true
                    });
                } else {
                    target[name] = method;
                }
            }
            function multiArgs(args, fn, from) {
                var result = [], i = from || 0, len;
                for (len = args.length; i < len; i++) {
                    result.push(args[i]);
                    if (fn) fn.call(args, args[i], i);
                }
                return result;
            }
            function flattenedArgs(args, fn, from) {
                var arg = args[from || 0];
                if (isArray(arg)) {
                    args = arg;
                    from = 0;
                }
                return multiArgs(args, fn, from);
            }
            function checkCallback(fn) {
                if (!fn || !fn.call) {
                    throw new TypeError("Callback is not callable");
                }
            }
            function isDefined(o) {
                return o !== Undefined;
            }
            function isUndefined(o) {
                return o === Undefined;
            }
            function hasProperty(obj, prop) {
                return !isPrimitiveType(obj) && prop in obj;
            }
            function hasOwnProperty(obj, prop) {
                return !!obj && internalHasOwnProperty.call(obj, prop);
            }
            function isObjectType(obj) {
                return !!obj && (typeof obj === "object" || regexIsFunction && isRegExp(obj));
            }
            function isPrimitiveType(obj) {
                var type = typeof obj;
                return obj == null || type === "string" || type === "number" || type === "boolean";
            }
            function isPlainObject(obj, klass) {
                klass = klass || className(obj);
                try {
                    if (obj && obj.constructor && !hasOwnProperty(obj, "constructor") && !hasOwnProperty(obj.constructor.prototype, "isPrototypeOf")) {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
                return !!obj && klass === "[object Object]" && "hasOwnProperty" in obj;
            }
            function iterateOverObject(obj, fn) {
                var key;
                for (key in obj) {
                    if (!hasOwnProperty(obj, key)) continue;
                    if (fn.call(obj, key, obj[key], obj) === false) break;
                }
            }
            function simpleRepeat(n, fn) {
                for (var i = 0; i < n; i++) {
                    fn(i);
                }
            }
            function simpleMerge(target, source) {
                iterateOverObject(source, function(key) {
                    target[key] = source[key];
                });
                return target;
            }
            function coercePrimitiveToObject(obj) {
                if (isPrimitiveType(obj)) {
                    obj = object(obj);
                }
                if (noKeysInStringObjects && isString(obj)) {
                    forceStringCoercion(obj);
                }
                return obj;
            }
            function forceStringCoercion(obj) {
                var i = 0, chr;
                while (chr = obj.charAt(i)) {
                    obj[i++] = chr;
                }
            }
            function Hash(obj) {
                simpleMerge(this, coercePrimitiveToObject(obj));
            }
            Hash.prototype.constructor = object;
            var abs = math.abs;
            var pow = math.pow;
            var ceil = math.ceil;
            var floor = math.floor;
            var round = math.round;
            var min = math.min;
            var max = math.max;
            function withPrecision(val, precision, fn) {
                var multiplier = pow(10, abs(precision || 0));
                fn = fn || round;
                if (precision < 0) multiplier = 1 / multiplier;
                return fn(val * multiplier) / multiplier;
            }
            var HalfWidthZeroCode = 48;
            var HalfWidthNineCode = 57;
            var FullWidthZeroCode = 65296;
            var FullWidthNineCode = 65305;
            var HalfWidthPeriod = ".";
            var FullWidthPeriod = "．";
            var HalfWidthComma = ",";
            var FullWidthDigits = "";
            var NumberNormalizeMap = {};
            var NumberNormalizeReg;
            function codeIsNumeral(code) {
                return code >= HalfWidthZeroCode && code <= HalfWidthNineCode || code >= FullWidthZeroCode && code <= FullWidthNineCode;
            }
            function buildNumberHelpers() {
                var digit, i;
                for (i = 0; i <= 9; i++) {
                    digit = chr(i + FullWidthZeroCode);
                    FullWidthDigits += digit;
                    NumberNormalizeMap[digit] = chr(i + HalfWidthZeroCode);
                }
                NumberNormalizeMap[HalfWidthComma] = "";
                NumberNormalizeMap[FullWidthPeriod] = HalfWidthPeriod;
                NumberNormalizeMap[HalfWidthPeriod] = HalfWidthPeriod;
                NumberNormalizeReg = regexp("[" + FullWidthDigits + FullWidthPeriod + HalfWidthComma + HalfWidthPeriod + "]", "g");
            }
            function chr(num) {
                return string.fromCharCode(num);
            }
            function getTrimmableCharacters() {
                return "	\n\f\r   ᠎             \u2028\u2029　\ufeff";
            }
            function repeatString(str, num) {
                var result = "", str = str.toString();
                while (num > 0) {
                    if (num & 1) {
                        result += str;
                    }
                    if (num >>= 1) {
                        str += str;
                    }
                }
                return result;
            }
            function stringToNumber(str, base) {
                var sanitized, isDecimal;
                sanitized = str.replace(NumberNormalizeReg, function(chr) {
                    var replacement = NumberNormalizeMap[chr];
                    if (replacement === HalfWidthPeriod) {
                        isDecimal = true;
                    }
                    return replacement;
                });
                return isDecimal ? parseFloat(sanitized) : parseInt(sanitized, base || 10);
            }
            function padNumber(num, place, sign, base) {
                var str = abs(num).toString(base || 10);
                str = repeatString("0", place - str.replace(/\.\d+/, "").length) + str;
                if (sign || num < 0) {
                    str = (num < 0 ? "-" : "+") + str;
                }
                return str;
            }
            function getOrdinalizedSuffix(num) {
                if (num >= 11 && num <= 13) {
                    return "th";
                } else {
                    switch (num % 10) {
                      case 1:
                        return "st";

                      case 2:
                        return "nd";

                      case 3:
                        return "rd";

                      default:
                        return "th";
                    }
                }
            }
            function getRegExpFlags(reg, add) {
                var flags = "";
                add = add || "";
                function checkFlag(prop, flag) {
                    if (prop || add.indexOf(flag) > -1) {
                        flags += flag;
                    }
                }
                checkFlag(reg.multiline, "m");
                checkFlag(reg.ignoreCase, "i");
                checkFlag(reg.global, "g");
                checkFlag(reg.sticky, "y");
                return flags;
            }
            function escapeRegExp(str) {
                if (!isString(str)) str = string(str);
                return str.replace(/([\\/\'*+?|()\[\]{}.^$])/g, "\\$1");
            }
            function callDateGet(d, method) {
                return d["get" + (d._utc ? "UTC" : "") + method]();
            }
            function callDateSet(d, method, value) {
                return d["set" + (d._utc && method != "ISOWeek" ? "UTC" : "") + method](value);
            }
            function stringify(thing, stack) {
                var type = typeof thing, thingIsObject, thingIsArray, klass, value, arr, key, i, len;
                if (type === "string") return thing;
                klass = internalToString.call(thing);
                thingIsObject = isPlainObject(thing, klass);
                thingIsArray = isArray(thing, klass);
                if (thing != null && thingIsObject || thingIsArray) {
                    if (!stack) stack = [];
                    if (stack.length > 1) {
                        i = stack.length;
                        while (i--) {
                            if (stack[i] === thing) {
                                return "CYC";
                            }
                        }
                    }
                    stack.push(thing);
                    value = thing.valueOf() + string(thing.constructor);
                    arr = thingIsArray ? thing : object.keys(thing).sort();
                    for (i = 0, len = arr.length; i < len; i++) {
                        key = thingIsArray ? i : arr[i];
                        value += key + stringify(thing[key], stack);
                    }
                    stack.pop();
                } else if (1 / thing === -Infinity) {
                    value = "-0";
                } else {
                    value = string(thing && thing.valueOf ? thing.valueOf() : thing);
                }
                return type + klass + value;
            }
            function isEqual(a, b) {
                if (a === b) {
                    return a !== 0 || 1 / a === 1 / b;
                } else if (objectIsMatchedByValue(a) && objectIsMatchedByValue(b)) {
                    return stringify(a) === stringify(b);
                }
                return false;
            }
            function objectIsMatchedByValue(obj) {
                var klass = className(obj);
                return matchedByValueReg.test(klass) || isPlainObject(obj, klass);
            }
            function getEntriesForIndexes(obj, args, isString) {
                var result, length = obj.length, argsLen = args.length, overshoot = args[argsLen - 1] !== false, multiple = argsLen > (overshoot ? 1 : 2);
                if (!multiple) {
                    return entryAtIndex(obj, length, args[0], overshoot, isString);
                }
                result = [];
                multiArgs(args, function(index) {
                    if (isBoolean(index)) return false;
                    result.push(entryAtIndex(obj, length, index, overshoot, isString));
                });
                return result;
            }
            function entryAtIndex(obj, length, index, overshoot, isString) {
                if (overshoot) {
                    index = index % length;
                    if (index < 0) index = length + index;
                }
                return isString ? obj.charAt(index) : obj[index];
            }
            function buildObjectInstanceMethods(set, target) {
                extendSimilar(target, true, false, set, function(methods, name) {
                    methods[name + (name === "equal" ? "s" : "")] = function() {
                        return object[name].apply(null, [ this ].concat(multiArgs(arguments)));
                    };
                });
            }
            initializeClasses();
            buildNumberHelpers();
            extend(object, false, false, {
                keys: function(obj) {
                    var keys = [];
                    if (!isObjectType(obj) && !isRegExp(obj) && !isFunction(obj)) {
                        throw new TypeError("Object required");
                    }
                    iterateOverObject(obj, function(key, value) {
                        keys.push(key);
                    });
                    return keys;
                }
            });
            function arrayIndexOf(arr, search, fromIndex, increment) {
                var length = arr.length, fromRight = increment == -1, start = fromRight ? length - 1 : 0, index = toIntegerWithDefault(fromIndex, start);
                if (index < 0) {
                    index = length + index;
                }
                if (!fromRight && index < 0 || fromRight && index >= length) {
                    index = start;
                }
                while (fromRight && index >= 0 || !fromRight && index < length) {
                    if (arr[index] === search) {
                        return index;
                    }
                    index += increment;
                }
                return -1;
            }
            function arrayReduce(arr, fn, initialValue, fromRight) {
                var length = arr.length, count = 0, defined = isDefined(initialValue), result, index;
                checkCallback(fn);
                if (length == 0 && !defined) {
                    throw new TypeError("Reduce called on empty array with no initial value");
                } else if (defined) {
                    result = initialValue;
                } else {
                    result = arr[fromRight ? length - 1 : count];
                    count++;
                }
                while (count < length) {
                    index = fromRight ? length - count - 1 : count;
                    if (index in arr) {
                        result = fn(result, arr[index], index, arr);
                    }
                    count++;
                }
                return result;
            }
            function toIntegerWithDefault(i, d) {
                if (isNaN(i)) {
                    return d;
                } else {
                    return parseInt(i >> 0);
                }
            }
            function checkFirstArgumentExists(args) {
                if (args.length === 0) {
                    throw new TypeError("First argument must be defined");
                }
            }
            extend(array, false, false, {
                isArray: function(obj) {
                    return isArray(obj);
                }
            });
            extend(array, true, false, {
                every: function(fn, scope) {
                    var length = this.length, index = 0;
                    checkFirstArgumentExists(arguments);
                    while (index < length) {
                        if (index in this && !fn.call(scope, this[index], index, this)) {
                            return false;
                        }
                        index++;
                    }
                    return true;
                },
                some: function(fn, scope) {
                    var length = this.length, index = 0;
                    checkFirstArgumentExists(arguments);
                    while (index < length) {
                        if (index in this && fn.call(scope, this[index], index, this)) {
                            return true;
                        }
                        index++;
                    }
                    return false;
                },
                map: function(fn, scope) {
                    var scope = arguments[1], length = this.length, index = 0, result = new Array(length);
                    checkFirstArgumentExists(arguments);
                    while (index < length) {
                        if (index in this) {
                            result[index] = fn.call(scope, this[index], index, this);
                        }
                        index++;
                    }
                    return result;
                },
                filter: function(fn) {
                    var scope = arguments[1];
                    var length = this.length, index = 0, result = [];
                    checkFirstArgumentExists(arguments);
                    while (index < length) {
                        if (index in this && fn.call(scope, this[index], index, this)) {
                            result.push(this[index]);
                        }
                        index++;
                    }
                    return result;
                },
                indexOf: function(search) {
                    var fromIndex = arguments[1];
                    if (isString(this)) return this.indexOf(search, fromIndex);
                    return arrayIndexOf(this, search, fromIndex, 1);
                },
                lastIndexOf: function(search) {
                    var fromIndex = arguments[1];
                    if (isString(this)) return this.lastIndexOf(search, fromIndex);
                    return arrayIndexOf(this, search, fromIndex, -1);
                },
                forEach: function(fn) {
                    var length = this.length, index = 0, scope = arguments[1];
                    checkCallback(fn);
                    while (index < length) {
                        if (index in this) {
                            fn.call(scope, this[index], index, this);
                        }
                        index++;
                    }
                },
                reduce: function(fn) {
                    return arrayReduce(this, fn, arguments[1]);
                },
                reduceRight: function(fn) {
                    return arrayReduce(this, fn, arguments[1], true);
                }
            });
            function buildTrim() {
                var support = getTrimmableCharacters().match(/^\s+$/);
                try {
                    string.prototype.trim.call([ 1 ]);
                } catch (e) {
                    support = false;
                }
                extend(string, true, !support, {
                    trim: function() {
                        return this.toString().trimLeft().trimRight();
                    },
                    trimLeft: function() {
                        return this.replace(regexp("^[" + getTrimmableCharacters() + "]+"), "");
                    },
                    trimRight: function() {
                        return this.replace(regexp("[" + getTrimmableCharacters() + "]+$"), "");
                    }
                });
            }
            extend(Function, true, false, {
                bind: function(scope) {
                    var fn = this, args = multiArgs(arguments, null, 1), bound;
                    if (!isFunction(this)) {
                        throw new TypeError("Function.prototype.bind called on a non-function");
                    }
                    bound = function() {
                        return fn.apply(fn.prototype && this instanceof fn ? this : scope, args.concat(multiArgs(arguments)));
                    };
                    bound.prototype = this.prototype;
                    return bound;
                }
            });
            extend(date, false, false, {
                now: function() {
                    return new date().getTime();
                }
            });
            function buildISOString() {
                var d = new date(date.UTC(1999, 11, 31)), target = "1999-12-31T00:00:00.000Z";
                var support = d.toISOString && d.toISOString() === target;
                extendSimilar(date, true, !support, "toISOString,toJSON", function(methods, name) {
                    methods[name] = function() {
                        return padNumber(this.getUTCFullYear(), 4) + "-" + padNumber(this.getUTCMonth() + 1, 2) + "-" + padNumber(this.getUTCDate(), 2) + "T" + padNumber(this.getUTCHours(), 2) + ":" + padNumber(this.getUTCMinutes(), 2) + ":" + padNumber(this.getUTCSeconds(), 2) + "." + padNumber(this.getUTCMilliseconds(), 3) + "Z";
                    };
                });
            }
            buildTrim();
            buildISOString();
            function regexMatcher(reg) {
                reg = regexp(reg);
                return function(el) {
                    return reg.test(el);
                };
            }
            function dateMatcher(d) {
                var ms = d.getTime();
                return function(el) {
                    return !!(el && el.getTime) && el.getTime() === ms;
                };
            }
            function functionMatcher(fn) {
                return function(el, i, arr) {
                    return el === fn || fn.call(this, el, i, arr);
                };
            }
            function invertedArgsFunctionMatcher(fn) {
                return function(value, key, obj) {
                    return value === fn || fn.call(obj, key, value, obj);
                };
            }
            function fuzzyMatcher(obj, isObject) {
                var matchers = {};
                return function(el, i, arr) {
                    var key;
                    if (!isObjectType(el)) {
                        return false;
                    }
                    for (key in obj) {
                        matchers[key] = matchers[key] || getMatcher(obj[key], isObject);
                        if (matchers[key].call(arr, el[key], i, arr) === false) {
                            return false;
                        }
                    }
                    return true;
                };
            }
            function defaultMatcher(f) {
                return function(el) {
                    return el === f || isEqual(el, f);
                };
            }
            function getMatcher(f, isObject) {
                if (isPrimitiveType(f)) {} else if (isRegExp(f)) {
                    return regexMatcher(f);
                } else if (isDate(f)) {
                    return dateMatcher(f);
                } else if (isFunction(f)) {
                    if (isObject) {
                        return invertedArgsFunctionMatcher(f);
                    } else {
                        return functionMatcher(f);
                    }
                } else if (isPlainObject(f)) {
                    return fuzzyMatcher(f, isObject);
                }
                return defaultMatcher(f);
            }
            function transformArgument(el, map, context, mapArgs) {
                if (!map) {
                    return el;
                } else if (map.apply) {
                    return map.apply(context, mapArgs || []);
                } else if (isFunction(el[map])) {
                    return el[map].call(el);
                } else {
                    return el[map];
                }
            }
            function arrayEach(arr, fn, startIndex, loop) {
                var index, i, length = +arr.length;
                if (startIndex < 0) startIndex = arr.length + startIndex;
                i = isNaN(startIndex) ? 0 : startIndex;
                if (loop === true) {
                    length += i;
                }
                while (i < length) {
                    index = i % arr.length;
                    if (!(index in arr)) {
                        return iterateOverSparseArray(arr, fn, i, loop);
                    } else if (fn.call(arr, arr[index], index, arr) === false) {
                        break;
                    }
                    i++;
                }
            }
            function iterateOverSparseArray(arr, fn, fromIndex, loop) {
                var indexes = [], i;
                for (i in arr) {
                    if (isArrayIndex(arr, i) && i >= fromIndex) {
                        indexes.push(parseInt(i));
                    }
                }
                indexes.sort().each(function(index) {
                    return fn.call(arr, arr[index], index, arr);
                });
                return arr;
            }
            function isArrayIndex(arr, i) {
                return i in arr && toUInt32(i) == i && i != 4294967295;
            }
            function toUInt32(i) {
                return i >>> 0;
            }
            function arrayFind(arr, f, startIndex, loop, returnIndex, context) {
                var result, index, matcher;
                if (arr.length > 0) {
                    matcher = getMatcher(f);
                    arrayEach(arr, function(el, i) {
                        if (matcher.call(context, el, i, arr)) {
                            result = el;
                            index = i;
                            return false;
                        }
                    }, startIndex, loop);
                }
                return returnIndex ? index : result;
            }
            function arrayUnique(arr, map) {
                var result = [], o = {}, transformed;
                arrayEach(arr, function(el, i) {
                    transformed = map ? transformArgument(el, map, arr, [ el, i, arr ]) : el;
                    if (!checkForElementInHashAndSet(o, transformed)) {
                        result.push(el);
                    }
                });
                return result;
            }
            function arrayIntersect(arr1, arr2, subtract) {
                var result = [], o = {};
                arr2.each(function(el) {
                    checkForElementInHashAndSet(o, el);
                });
                arr1.each(function(el) {
                    var stringified = stringify(el), isReference = !objectIsMatchedByValue(el);
                    if (elementExistsInHash(o, stringified, el, isReference) !== subtract) {
                        discardElementFromHash(o, stringified, el, isReference);
                        result.push(el);
                    }
                });
                return result;
            }
            function arrayFlatten(arr, level, current) {
                level = level || Infinity;
                current = current || 0;
                var result = [];
                arrayEach(arr, function(el) {
                    if (isArray(el) && current < level) {
                        result = result.concat(arrayFlatten(el, level, current + 1));
                    } else {
                        result.push(el);
                    }
                });
                return result;
            }
            function isArrayLike(obj) {
                return hasProperty(obj, "length") && !isString(obj) && !isPlainObject(obj);
            }
            function isArgumentsObject(obj) {
                return hasProperty(obj, "length") && (className(obj) === "[object Arguments]" || !!obj.callee);
            }
            function flatArguments(args) {
                var result = [];
                multiArgs(args, function(arg) {
                    result = result.concat(arg);
                });
                return result;
            }
            function elementExistsInHash(hash, key, element, isReference) {
                var exists = key in hash;
                if (isReference) {
                    if (!hash[key]) {
                        hash[key] = [];
                    }
                    exists = hash[key].indexOf(element) !== -1;
                }
                return exists;
            }
            function checkForElementInHashAndSet(hash, element) {
                var stringified = stringify(element), isReference = !objectIsMatchedByValue(element), exists = elementExistsInHash(hash, stringified, element, isReference);
                if (isReference) {
                    hash[stringified].push(element);
                } else {
                    hash[stringified] = element;
                }
                return exists;
            }
            function discardElementFromHash(hash, key, element, isReference) {
                var arr, i = 0;
                if (isReference) {
                    arr = hash[key];
                    while (i < arr.length) {
                        if (arr[i] === element) {
                            arr.splice(i, 1);
                        } else {
                            i += 1;
                        }
                    }
                } else {
                    delete hash[key];
                }
            }
            function getMinOrMax(obj, map, which, all) {
                var el, key, edge, test, result = [], max = which === "max", min = which === "min", isArray = array.isArray(obj);
                for (key in obj) {
                    if (!obj.hasOwnProperty(key)) continue;
                    el = obj[key];
                    test = transformArgument(el, map, obj, isArray ? [ el, parseInt(key), obj ] : []);
                    if (isUndefined(test)) {
                        throw new TypeError("Cannot compare with undefined");
                    }
                    if (test === edge) {
                        result.push(el);
                    } else if (isUndefined(edge) || max && test > edge || min && test < edge) {
                        result = [ el ];
                        edge = test;
                    }
                }
                if (!isArray) result = arrayFlatten(result, 1);
                return all ? result : result[0];
            }
            function collateStrings(a, b) {
                var aValue, bValue, aChar, bChar, aEquiv, bEquiv, index = 0, tiebreaker = 0;
                var sortIgnore = array[AlphanumericSortIgnore];
                var sortIgnoreCase = array[AlphanumericSortIgnoreCase];
                var sortEquivalents = array[AlphanumericSortEquivalents];
                var sortOrder = array[AlphanumericSortOrder];
                var naturalSort = array[AlphanumericSortNatural];
                a = getCollationReadyString(a, sortIgnore, sortIgnoreCase);
                b = getCollationReadyString(b, sortIgnore, sortIgnoreCase);
                do {
                    aChar = getCollationCharacter(a, index, sortEquivalents);
                    bChar = getCollationCharacter(b, index, sortEquivalents);
                    aValue = getSortOrderIndex(aChar, sortOrder);
                    bValue = getSortOrderIndex(bChar, sortOrder);
                    if (aValue === -1 || bValue === -1) {
                        aValue = a.charCodeAt(index) || null;
                        bValue = b.charCodeAt(index) || null;
                        if (naturalSort && codeIsNumeral(aValue) && codeIsNumeral(bValue)) {
                            aValue = stringToNumber(a.slice(index));
                            bValue = stringToNumber(b.slice(index));
                        }
                    } else {
                        aEquiv = aChar !== a.charAt(index);
                        bEquiv = bChar !== b.charAt(index);
                        if (aEquiv !== bEquiv && tiebreaker === 0) {
                            tiebreaker = aEquiv - bEquiv;
                        }
                    }
                    index += 1;
                } while (aValue != null && bValue != null && aValue === bValue);
                if (aValue === bValue) return tiebreaker;
                return aValue - bValue;
            }
            function getCollationReadyString(str, sortIgnore, sortIgnoreCase) {
                if (!isString(str)) str = string(str);
                if (sortIgnoreCase) {
                    str = str.toLowerCase();
                }
                if (sortIgnore) {
                    str = str.replace(sortIgnore, "");
                }
                return str;
            }
            function getCollationCharacter(str, index, sortEquivalents) {
                var chr = str.charAt(index);
                return sortEquivalents[chr] || chr;
            }
            function getSortOrderIndex(chr, sortOrder) {
                if (!chr) {
                    return null;
                } else {
                    return sortOrder.indexOf(chr);
                }
            }
            var AlphanumericSort = "AlphanumericSort";
            var AlphanumericSortOrder = "AlphanumericSortOrder";
            var AlphanumericSortIgnore = "AlphanumericSortIgnore";
            var AlphanumericSortIgnoreCase = "AlphanumericSortIgnoreCase";
            var AlphanumericSortEquivalents = "AlphanumericSortEquivalents";
            var AlphanumericSortNatural = "AlphanumericSortNatural";
            function buildEnhancements() {
                var nativeMap = array.prototype.map;
                var callbackCheck = function() {
                    var args = arguments;
                    return args.length > 0 && !isFunction(args[0]);
                };
                extendSimilar(array, true, callbackCheck, "every,all,some,filter,any,none,find,findIndex", function(methods, name) {
                    var nativeFn = array.prototype[name];
                    methods[name] = function(f) {
                        var matcher = getMatcher(f);
                        return nativeFn.call(this, function(el, index) {
                            return matcher(el, index, this);
                        });
                    };
                });
                extend(array, true, callbackCheck, {
                    map: function(f) {
                        return nativeMap.call(this, function(el, index) {
                            return transformArgument(el, f, this, [ el, index, this ]);
                        });
                    }
                });
            }
            function buildAlphanumericSort() {
                var order = "AÁÀÂÃĄBCĆČÇDĎÐEÉÈĚÊËĘFGĞHıIÍÌİÎÏJKLŁMNŃŇÑOÓÒÔPQRŘSŚŠŞTŤUÚÙŮÛÜVWXYÝZŹŻŽÞÆŒØÕÅÄÖ";
                var equiv = "AÁÀÂÃÄ,CÇ,EÉÈÊË,IÍÌİÎÏ,OÓÒÔÕÖ,Sß,UÚÙÛÜ";
                array[AlphanumericSortOrder] = order.split("").map(function(str) {
                    return str + str.toLowerCase();
                }).join("");
                var equivalents = {};
                arrayEach(equiv.split(","), function(set) {
                    var equivalent = set.charAt(0);
                    arrayEach(set.slice(1).split(""), function(chr) {
                        equivalents[chr] = equivalent;
                        equivalents[chr.toLowerCase()] = equivalent.toLowerCase();
                    });
                });
                array[AlphanumericSortNatural] = true;
                array[AlphanumericSortIgnoreCase] = true;
                array[AlphanumericSortEquivalents] = equivalents;
            }
            extend(array, false, true, {
                create: function() {
                    var result = [];
                    multiArgs(arguments, function(a) {
                        if (isArgumentsObject(a) || isArrayLike(a)) {
                            a = array.prototype.slice.call(a, 0);
                        }
                        result = result.concat(a);
                    });
                    return result;
                }
            });
            extend(array, true, false, {
                find: function(f, context) {
                    checkCallback(f);
                    return arrayFind(this, f, 0, false, false, context);
                },
                findIndex: function(f, context) {
                    var index;
                    checkCallback(f);
                    index = arrayFind(this, f, 0, false, true, context);
                    return isUndefined(index) ? -1 : index;
                }
            });
            extend(array, true, true, {
                findFrom: function(f, index, loop) {
                    return arrayFind(this, f, index, loop);
                },
                findIndexFrom: function(f, index, loop) {
                    var index = arrayFind(this, f, index, loop, true);
                    return isUndefined(index) ? -1 : index;
                },
                findAll: function(f, index, loop) {
                    var result = [], matcher;
                    if (this.length > 0) {
                        matcher = getMatcher(f);
                        arrayEach(this, function(el, i, arr) {
                            if (matcher(el, i, arr)) {
                                result.push(el);
                            }
                        }, index, loop);
                    }
                    return result;
                },
                count: function(f) {
                    if (isUndefined(f)) return this.length;
                    return this.findAll(f).length;
                },
                removeAt: function(start, end) {
                    if (isUndefined(start)) return this;
                    if (isUndefined(end)) end = start;
                    this.splice(start, end - start + 1);
                    return this;
                },
                include: function(el, index) {
                    return this.clone().add(el, index);
                },
                exclude: function() {
                    return array.prototype.remove.apply(this.clone(), arguments);
                },
                clone: function() {
                    return simpleMerge([], this);
                },
                unique: function(map) {
                    return arrayUnique(this, map);
                },
                flatten: function(limit) {
                    return arrayFlatten(this, limit);
                },
                union: function() {
                    return arrayUnique(this.concat(flatArguments(arguments)));
                },
                intersect: function() {
                    return arrayIntersect(this, flatArguments(arguments), false);
                },
                subtract: function(a) {
                    return arrayIntersect(this, flatArguments(arguments), true);
                },
                at: function() {
                    return getEntriesForIndexes(this, arguments);
                },
                first: function(num) {
                    if (isUndefined(num)) return this[0];
                    if (num < 0) num = 0;
                    return this.slice(0, num);
                },
                last: function(num) {
                    if (isUndefined(num)) return this[this.length - 1];
                    var start = this.length - num < 0 ? 0 : this.length - num;
                    return this.slice(start);
                },
                from: function(num) {
                    return this.slice(num);
                },
                to: function(num) {
                    if (isUndefined(num)) num = this.length;
                    return this.slice(0, num);
                },
                min: function(map, all) {
                    return getMinOrMax(this, map, "min", all);
                },
                max: function(map, all) {
                    return getMinOrMax(this, map, "max", all);
                },
                least: function(map, all) {
                    return getMinOrMax(this.groupBy.apply(this, [ map ]), "length", "min", all);
                },
                most: function(map, all) {
                    return getMinOrMax(this.groupBy.apply(this, [ map ]), "length", "max", all);
                },
                sum: function(map) {
                    var arr = map ? this.map(map) : this;
                    return arr.length > 0 ? arr.reduce(function(a, b) {
                        return a + b;
                    }) : 0;
                },
                average: function(map) {
                    var arr = map ? this.map(map) : this;
                    return arr.length > 0 ? arr.sum() / arr.length : 0;
                },
                inGroups: function(num, padding) {
                    var pad = arguments.length > 1;
                    var arr = this;
                    var result = [];
                    var divisor = ceil(this.length / num);
                    simpleRepeat(num, function(i) {
                        var index = i * divisor;
                        var group = arr.slice(index, index + divisor);
                        if (pad && group.length < divisor) {
                            simpleRepeat(divisor - group.length, function() {
                                group = group.add(padding);
                            });
                        }
                        result.push(group);
                    });
                    return result;
                },
                inGroupsOf: function(num, padding) {
                    var result = [], len = this.length, arr = this, group;
                    if (len === 0 || num === 0) return arr;
                    if (isUndefined(num)) num = 1;
                    if (isUndefined(padding)) padding = null;
                    simpleRepeat(ceil(len / num), function(i) {
                        group = arr.slice(num * i, num * i + num);
                        while (group.length < num) {
                            group.push(padding);
                        }
                        result.push(group);
                    });
                    return result;
                },
                isEmpty: function() {
                    return this.compact().length == 0;
                },
                sortBy: function(map, desc) {
                    var arr = this.clone();
                    arr.sort(function(a, b) {
                        var aProperty, bProperty, comp;
                        aProperty = transformArgument(a, map, arr, [ a ]);
                        bProperty = transformArgument(b, map, arr, [ b ]);
                        if (isString(aProperty) && isString(bProperty)) {
                            comp = collateStrings(aProperty, bProperty);
                        } else if (aProperty < bProperty) {
                            comp = -1;
                        } else if (aProperty > bProperty) {
                            comp = 1;
                        } else {
                            comp = 0;
                        }
                        return comp * (desc ? -1 : 1);
                    });
                    return arr;
                },
                randomize: function() {
                    var arr = this.concat(), i = arr.length, j, x;
                    while (i) {
                        j = math.random() * i | 0;
                        x = arr[--i];
                        arr[i] = arr[j];
                        arr[j] = x;
                    }
                    return arr;
                },
                zip: function() {
                    var args = multiArgs(arguments);
                    return this.map(function(el, i) {
                        return [ el ].concat(args.map(function(k) {
                            return i in k ? k[i] : null;
                        }));
                    });
                },
                sample: function(num) {
                    var arr = this.randomize();
                    return arguments.length > 0 ? arr.slice(0, num) : arr[0];
                },
                each: function(fn, index, loop) {
                    arrayEach(this, fn, index, loop);
                    return this;
                },
                add: function(el, index) {
                    if (!isNumber(number(index)) || isNaN(index)) index = this.length;
                    array.prototype.splice.apply(this, [ index, 0 ].concat(el));
                    return this;
                },
                remove: function() {
                    var arr = this;
                    multiArgs(arguments, function(f) {
                        var i = 0, matcher = getMatcher(f);
                        while (i < arr.length) {
                            if (matcher(arr[i], i, arr)) {
                                arr.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    });
                    return arr;
                },
                compact: function(all) {
                    var result = [];
                    arrayEach(this, function(el, i) {
                        if (isArray(el)) {
                            result.push(el.compact());
                        } else if (all && el) {
                            result.push(el);
                        } else if (!all && el != null && el.valueOf() === el.valueOf()) {
                            result.push(el);
                        }
                    });
                    return result;
                },
                groupBy: function(map, fn) {
                    var arr = this, result = {}, key;
                    arrayEach(arr, function(el, index) {
                        key = transformArgument(el, map, arr, [ el, index, arr ]);
                        if (!result[key]) result[key] = [];
                        result[key].push(el);
                    });
                    if (fn) {
                        iterateOverObject(result, fn);
                    }
                    return result;
                },
                none: function() {
                    return !this.any.apply(this, arguments);
                }
            });
            extend(array, true, true, {
                all: array.prototype.every,
                any: array.prototype.some,
                insert: array.prototype.add
            });
            function keysWithObjectCoercion(obj) {
                return object.keys(coercePrimitiveToObject(obj));
            }
            function buildEnumerableMethods(names, mapping) {
                extendSimilar(object, false, true, names, function(methods, name) {
                    methods[name] = function(obj, arg1, arg2) {
                        var result, coerced = keysWithObjectCoercion(obj), matcher;
                        if (!mapping) {
                            matcher = getMatcher(arg1, true);
                        }
                        result = array.prototype[name].call(coerced, function(key) {
                            var value = obj[key];
                            if (mapping) {
                                return transformArgument(value, arg1, obj, [ key, value, obj ]);
                            } else {
                                return matcher(value, key, obj);
                            }
                        }, arg2);
                        if (isArray(result)) {
                            result = result.reduce(function(o, key, i) {
                                o[key] = obj[key];
                                return o;
                            }, {});
                        }
                        return result;
                    };
                });
                buildObjectInstanceMethods(names, Hash);
            }
            function exportSortAlgorithm() {
                array[AlphanumericSort] = collateStrings;
            }
            extend(object, false, true, {
                map: function(obj, map) {
                    var result = {}, key, value;
                    for (key in obj) {
                        if (!hasOwnProperty(obj, key)) continue;
                        value = obj[key];
                        result[key] = transformArgument(value, map, obj, [ key, value, obj ]);
                    }
                    return result;
                },
                reduce: function(obj) {
                    var values = keysWithObjectCoercion(obj).map(function(key) {
                        return obj[key];
                    });
                    return values.reduce.apply(values, multiArgs(arguments, null, 1));
                },
                each: function(obj, fn) {
                    checkCallback(fn);
                    iterateOverObject(obj, fn);
                    return obj;
                },
                size: function(obj) {
                    return keysWithObjectCoercion(obj).length;
                }
            });
            var EnumerableFindingMethods = "any,all,none,count,find,findAll,isEmpty".split(",");
            var EnumerableMappingMethods = "sum,average,min,max,least,most".split(",");
            var EnumerableOtherMethods = "map,reduce,size".split(",");
            var EnumerableMethods = EnumerableFindingMethods.concat(EnumerableMappingMethods).concat(EnumerableOtherMethods);
            buildEnhancements();
            buildAlphanumericSort();
            buildEnumerableMethods(EnumerableFindingMethods);
            buildEnumerableMethods(EnumerableMappingMethods, true);
            buildObjectInstanceMethods(EnumerableOtherMethods, Hash);
            exportSortAlgorithm();
            var English;
            var CurrentLocalization;
            var TimeFormat = [ "ampm", "hour", "minute", "second", "ampm", "utc", "offset_sign", "offset_hours", "offset_minutes", "ampm" ];
            var DecimalReg = "(?:[,.]\\d+)?";
            var HoursReg = "\\d{1,2}" + DecimalReg;
            var SixtyReg = "[0-5]\\d" + DecimalReg;
            var RequiredTime = "({t})?\\s*(" + HoursReg + ")(?:{h}(" + SixtyReg + ")?{m}(?::?(" + SixtyReg + "){s})?\\s*(?:({t})|(Z)|(?:([+-])(\\d{2,2})(?::?(\\d{2,2}))?)?)?|\\s*({t}))";
            var KanjiDigits = "〇一二三四五六七八九十百千万";
            var AsianDigitMap = {};
            var AsianDigitReg;
            var DateArgumentUnits;
            var DateUnitsReversed;
            var CoreDateFormats = [];
            var CompiledOutputFormats = {};
            var DateFormatTokens = {
                yyyy: function(d) {
                    return callDateGet(d, "FullYear");
                },
                yy: function(d) {
                    return callDateGet(d, "FullYear") % 100;
                },
                ord: function(d) {
                    var date = callDateGet(d, "Date");
                    return date + getOrdinalizedSuffix(date);
                },
                tz: function(d) {
                    return d.getUTCOffset();
                },
                isotz: function(d) {
                    return d.getUTCOffset(true);
                },
                Z: function(d) {
                    return d.getUTCOffset();
                },
                ZZ: function(d) {
                    return d.getUTCOffset().replace(/(\d{2})$/, ":$1");
                }
            };
            var DateUnits = [ {
                name: "year",
                method: "FullYear",
                ambiguous: true,
                multiplier: function(d) {
                    var adjust = d ? d.isLeapYear() ? 1 : 0 : .25;
                    return (365 + adjust) * 24 * 60 * 60 * 1e3;
                }
            }, {
                name: "month",
                error: .919,
                method: "Month",
                ambiguous: true,
                multiplier: function(d, ms) {
                    var days = 30.4375, inMonth;
                    if (d) {
                        inMonth = d.daysInMonth();
                        if (ms <= inMonth.days()) {
                            days = inMonth;
                        }
                    }
                    return days * 24 * 60 * 60 * 1e3;
                }
            }, {
                name: "week",
                method: "ISOWeek",
                multiplier: function() {
                    return 7 * 24 * 60 * 60 * 1e3;
                }
            }, {
                name: "day",
                error: .958,
                method: "Date",
                ambiguous: true,
                multiplier: function() {
                    return 24 * 60 * 60 * 1e3;
                }
            }, {
                name: "hour",
                method: "Hours",
                multiplier: function() {
                    return 60 * 60 * 1e3;
                }
            }, {
                name: "minute",
                method: "Minutes",
                multiplier: function() {
                    return 60 * 1e3;
                }
            }, {
                name: "second",
                method: "Seconds",
                multiplier: function() {
                    return 1e3;
                }
            }, {
                name: "millisecond",
                method: "Milliseconds",
                multiplier: function() {
                    return 1;
                }
            } ];
            var Localizations = {};
            function Localization(l) {
                simpleMerge(this, l);
                this.compiledFormats = CoreDateFormats.concat();
            }
            Localization.prototype = {
                getMonth: function(n) {
                    if (isNumber(n)) {
                        return n - 1;
                    } else {
                        return this["months"].indexOf(n) % 12;
                    }
                },
                getWeekday: function(n) {
                    return this["weekdays"].indexOf(n) % 7;
                },
                getNumber: function(n) {
                    var i;
                    if (isNumber(n)) {
                        return n;
                    } else if (n && (i = this["numbers"].indexOf(n)) !== -1) {
                        return (i + 1) % 10;
                    } else {
                        return 1;
                    }
                },
                getNumericDate: function(n) {
                    var self = this;
                    return n.replace(regexp(this["num"], "g"), function(d) {
                        var num = self.getNumber(d);
                        return num || "";
                    });
                },
                getUnitIndex: function(n) {
                    return this["units"].indexOf(n) % 8;
                },
                getRelativeFormat: function(adu) {
                    return this.convertAdjustedToFormat(adu, adu[2] > 0 ? "future" : "past");
                },
                getDuration: function(ms) {
                    return this.convertAdjustedToFormat(getAdjustedUnit(ms), "duration");
                },
                hasVariant: function(code) {
                    code = code || this.code;
                    return code === "en" || code === "en-US" ? true : this["variant"];
                },
                matchAM: function(str) {
                    return str === this["ampm"][0];
                },
                matchPM: function(str) {
                    return str && str === this["ampm"][1];
                },
                convertAdjustedToFormat: function(adu, mode) {
                    var sign, unit, mult, num = adu[0], u = adu[1], ms = adu[2], format = this[mode] || this["relative"];
                    if (isFunction(format)) {
                        return format.call(this, num, u, ms, mode);
                    }
                    mult = this["plural"] && num > 1 ? 1 : 0;
                    unit = this["units"][mult * 8 + u] || this["units"][u];
                    if (this["capitalizeUnit"]) unit = simpleCapitalize(unit);
                    sign = this["modifiers"].filter(function(m) {
                        return m.name == "sign" && m.value == (ms > 0 ? 1 : -1);
                    })[0];
                    return format.replace(/\{(.*?)\}/g, function(full, match) {
                        switch (match) {
                          case "num":
                            return num;

                          case "unit":
                            return unit;

                          case "sign":
                            return sign.src;
                        }
                    });
                },
                getFormats: function() {
                    return this.cachedFormat ? [ this.cachedFormat ].concat(this.compiledFormats) : this.compiledFormats;
                },
                addFormat: function(src, allowsTime, match, variant, iso) {
                    var to = match || [], loc = this, time, timeMarkers, lastIsNumeral;
                    src = src.replace(/\s+/g, "[,. ]*");
                    src = src.replace(/\{([^,]+?)\}/g, function(all, k) {
                        var value, arr, result, opt = k.match(/\?$/), nc = k.match(/^(\d+)\??$/), slice = k.match(/(\d)(?:-(\d))?/), key = k.replace(/[^a-z]+$/, "");
                        if (nc) {
                            value = loc["tokens"][nc[1]];
                        } else if (loc[key]) {
                            value = loc[key];
                        } else if (loc[key + "s"]) {
                            value = loc[key + "s"];
                            if (slice) {
                                arr = [];
                                value.forEach(function(m, i) {
                                    var mod = i % (loc["units"] ? 8 : value.length);
                                    if (mod >= slice[1] && mod <= (slice[2] || slice[1])) {
                                        arr.push(m);
                                    }
                                });
                                value = arr;
                            }
                            value = arrayToAlternates(value);
                        }
                        if (nc) {
                            result = "(?:" + value + ")";
                        } else {
                            if (!match) {
                                to.push(key);
                            }
                            result = "(" + value + ")";
                        }
                        if (opt) {
                            result += "?";
                        }
                        return result;
                    });
                    if (allowsTime) {
                        time = prepareTime(RequiredTime, loc, iso);
                        timeMarkers = [ "t", "[\\s\\u3000]" ].concat(loc["timeMarker"]);
                        lastIsNumeral = src.match(/\\d\{\d,\d\}\)+\??$/);
                        addDateInputFormat(loc, "(?:" + time + ")[,\\s\\u3000]+?" + src, TimeFormat.concat(to), variant);
                        addDateInputFormat(loc, src + "(?:[,\\s]*(?:" + timeMarkers.join("|") + (lastIsNumeral ? "+" : "*") + ")" + time + ")?", to.concat(TimeFormat), variant);
                    } else {
                        addDateInputFormat(loc, src, to, variant);
                    }
                }
            };
            function getLocalization(localeCode, fallback) {
                var loc;
                if (!isString(localeCode)) localeCode = "";
                loc = Localizations[localeCode] || Localizations[localeCode.slice(0, 2)];
                if (fallback === false && !loc) {
                    throw new TypeError("Invalid locale.");
                }
                return loc || CurrentLocalization;
            }
            function setLocalization(localeCode, set) {
                var loc, canAbbreviate;
                function initializeField(name) {
                    var val = loc[name];
                    if (isString(val)) {
                        loc[name] = val.split(",");
                    } else if (!val) {
                        loc[name] = [];
                    }
                }
                function eachAlternate(str, fn) {
                    str = str.split("+").map(function(split) {
                        return split.replace(/(.+):(.+)$/, function(full, base, suffixes) {
                            return suffixes.split("|").map(function(suffix) {
                                return base + suffix;
                            }).join("|");
                        });
                    }).join("|");
                    return str.split("|").forEach(fn);
                }
                function setArray(name, abbreviate, multiple) {
                    var arr = [];
                    loc[name].forEach(function(full, i) {
                        if (abbreviate) {
                            full += "+" + full.slice(0, 3);
                        }
                        eachAlternate(full, function(day, j) {
                            arr[j * multiple + i] = day.toLowerCase();
                        });
                    });
                    loc[name] = arr;
                }
                function getDigit(start, stop, allowNumbers) {
                    var str = "\\d{" + start + "," + stop + "}";
                    if (allowNumbers) str += "|(?:" + arrayToAlternates(loc["numbers"]) + ")+";
                    return str;
                }
                function getNum() {
                    var arr = [ "-?\\d+" ].concat(loc["articles"]);
                    if (loc["numbers"]) arr = arr.concat(loc["numbers"]);
                    return arrayToAlternates(arr);
                }
                function setDefault(name, value) {
                    loc[name] = loc[name] || value;
                }
                function setModifiers() {
                    var arr = [];
                    loc.modifiersByName = {};
                    loc["modifiers"].push({
                        name: "day",
                        src: "yesterday",
                        value: -1
                    });
                    loc["modifiers"].push({
                        name: "day",
                        src: "today",
                        value: 0
                    });
                    loc["modifiers"].push({
                        name: "day",
                        src: "tomorrow",
                        value: 1
                    });
                    loc["modifiers"].forEach(function(modifier) {
                        var name = modifier.name;
                        eachAlternate(modifier.src, function(t) {
                            var locEntry = loc[name];
                            loc.modifiersByName[t] = modifier;
                            arr.push({
                                name: name,
                                src: t,
                                value: modifier.value
                            });
                            loc[name] = locEntry ? locEntry + "|" + t : t;
                        });
                    });
                    loc["day"] += "|" + arrayToAlternates(loc["weekdays"]);
                    loc["modifiers"] = arr;
                }
                loc = new Localization(set);
                initializeField("modifiers");
                "months,weekdays,units,numbers,articles,tokens,timeMarker,ampm,timeSuffixes,dateParse,timeParse".split(",").forEach(initializeField);
                canAbbreviate = !loc["monthSuffix"];
                setArray("months", canAbbreviate, 12);
                setArray("weekdays", canAbbreviate, 7);
                setArray("units", false, 8);
                setArray("numbers", false, 10);
                setDefault("code", localeCode);
                setDefault("date", getDigit(1, 2, loc["digitDate"]));
                setDefault("year", "'\\d{2}|" + getDigit(4, 4));
                setDefault("num", getNum());
                setModifiers();
                if (loc["monthSuffix"]) {
                    loc["month"] = getDigit(1, 2);
                    loc["months"] = "1,2,3,4,5,6,7,8,9,10,11,12".split(",").map(function(n) {
                        return n + loc["monthSuffix"];
                    });
                }
                loc["full_month"] = getDigit(1, 2) + "|" + arrayToAlternates(loc["months"]);
                if (loc["timeSuffixes"].length > 0) {
                    loc.addFormat(prepareTime(RequiredTime, loc), false, TimeFormat);
                }
                loc.addFormat("{day}", true);
                loc.addFormat("{month}" + (loc["monthSuffix"] || ""));
                loc.addFormat("{year}" + (loc["yearSuffix"] || ""));
                loc["timeParse"].forEach(function(src) {
                    loc.addFormat(src, true);
                });
                loc["dateParse"].forEach(function(src) {
                    loc.addFormat(src);
                });
                return Localizations[localeCode] = loc;
            }
            function addDateInputFormat(locale, format, match, variant) {
                locale.compiledFormats.unshift({
                    variant: variant,
                    locale: locale,
                    reg: regexp("^" + format + "$", "i"),
                    to: match
                });
            }
            function simpleCapitalize(str) {
                return str.slice(0, 1).toUpperCase() + str.slice(1);
            }
            function arrayToAlternates(arr) {
                return arr.filter(function(el) {
                    return !!el;
                }).join("|");
            }
            function getNewDate() {
                var fn = date.SugarNewDate;
                return fn ? fn() : new date();
            }
            function collectDateArguments(args, allowDuration) {
                var obj;
                if (isObjectType(args[0])) {
                    return args;
                } else if (isNumber(args[0]) && !isNumber(args[1])) {
                    return [ args[0] ];
                } else if (isString(args[0]) && allowDuration) {
                    return [ getDateParamsFromString(args[0]), args[1] ];
                }
                obj = {};
                DateArgumentUnits.forEach(function(u, i) {
                    obj[u.name] = args[i];
                });
                return [ obj ];
            }
            function getDateParamsFromString(str, num) {
                var match, params = {};
                match = str.match(/^(\d+)?\s?(\w+?)s?$/i);
                if (match) {
                    if (isUndefined(num)) {
                        num = parseInt(match[1]) || 1;
                    }
                    params[match[2].toLowerCase()] = num;
                }
                return params;
            }
            function iterateOverDateUnits(fn, from, to) {
                var i, unit;
                if (isUndefined(to)) to = DateUnitsReversed.length;
                for (i = from || 0; i < to; i++) {
                    unit = DateUnitsReversed[i];
                    if (fn(unit.name, unit, i) === false) {
                        break;
                    }
                }
            }
            function getFormatMatch(match, arr) {
                var obj = {}, value, num;
                arr.forEach(function(key, i) {
                    value = match[i + 1];
                    if (isUndefined(value) || value === "") return;
                    if (key === "year") {
                        obj.yearAsString = value.replace(/'/, "");
                    }
                    num = parseFloat(value.replace(/'/, "").replace(/,/, "."));
                    obj[key] = !isNaN(num) ? num : value.toLowerCase();
                });
                return obj;
            }
            function cleanDateInput(str) {
                str = str.trim().replace(/^just (?=now)|\.+$/i, "");
                return convertAsianDigits(str);
            }
            function convertAsianDigits(str) {
                return str.replace(AsianDigitReg, function(full, disallowed, match) {
                    var sum = 0, place = 1, lastWasHolder, lastHolder;
                    if (disallowed) return full;
                    match.split("").reverse().forEach(function(letter) {
                        var value = AsianDigitMap[letter], holder = value > 9;
                        if (holder) {
                            if (lastWasHolder) sum += place;
                            place *= value / (lastHolder || 1);
                            lastHolder = value;
                        } else {
                            if (lastWasHolder === false) {
                                place *= 10;
                            }
                            sum += place * value;
                        }
                        lastWasHolder = holder;
                    });
                    if (lastWasHolder) sum += place;
                    return sum;
                });
            }
            function getExtendedDate(f, localeCode, prefer, forceUTC) {
                var d, relative, baseLocalization, afterCallbacks, loc, set, unit, unitIndex, weekday, num, tmp;
                d = getNewDate();
                afterCallbacks = [];
                function afterDateSet(fn) {
                    afterCallbacks.push(fn);
                }
                function fireCallbacks() {
                    afterCallbacks.forEach(function(fn) {
                        fn.call();
                    });
                }
                function setWeekdayOfMonth() {
                    var w = d.getWeekday();
                    d.setWeekday(7 * (set["num"] - 1) + (w > weekday ? weekday + 7 : weekday));
                }
                function setUnitEdge() {
                    var modifier = loc.modifiersByName[set["edge"]];
                    iterateOverDateUnits(function(name) {
                        if (isDefined(set[name])) {
                            unit = name;
                            return false;
                        }
                    }, 4);
                    if (unit === "year") set.specificity = "month"; else if (unit === "month" || unit === "week") set.specificity = "day";
                    d[(modifier.value < 0 ? "endOf" : "beginningOf") + simpleCapitalize(unit)]();
                    if (modifier.value === -2) d.reset();
                }
                function separateAbsoluteUnits() {
                    var params;
                    iterateOverDateUnits(function(name, u, i) {
                        if (name === "day") name = "date";
                        if (isDefined(set[name])) {
                            if (i >= unitIndex) {
                                invalidateDate(d);
                                return false;
                            }
                            params = params || {};
                            params[name] = set[name];
                            delete set[name];
                        }
                    });
                    if (params) {
                        afterDateSet(function() {
                            d.set(params, true);
                        });
                    }
                }
                d.utc(forceUTC);
                if (isDate(f)) {
                    d.utc(f.isUTC()).setTime(f.getTime());
                } else if (isNumber(f)) {
                    d.setTime(f);
                } else if (isObjectType(f)) {
                    d.set(f, true);
                    set = f;
                } else if (isString(f)) {
                    baseLocalization = getLocalization(localeCode);
                    f = cleanDateInput(f);
                    if (baseLocalization) {
                        iterateOverObject(baseLocalization.getFormats(), function(i, dif) {
                            var match = f.match(dif.reg);
                            if (match) {
                                loc = dif.locale;
                                set = getFormatMatch(match, dif.to, loc);
                                loc.cachedFormat = dif;
                                if (set["utc"]) {
                                    d.utc();
                                }
                                if (set.timestamp) {
                                    set = set.timestamp;
                                    return false;
                                }
                                if (dif.variant && !isString(set["month"]) && (isString(set["date"]) || baseLocalization.hasVariant(localeCode))) {
                                    tmp = set["month"];
                                    set["month"] = set["date"];
                                    set["date"] = tmp;
                                }
                                if (set["year"] && set.yearAsString.length === 2) {
                                    set["year"] = getYearFromAbbreviation(set["year"]);
                                }
                                if (set["month"]) {
                                    set["month"] = loc.getMonth(set["month"]);
                                    if (set["shift"] && !set["unit"]) set["unit"] = loc["units"][7];
                                }
                                if (set["weekday"] && set["date"]) {
                                    delete set["weekday"];
                                } else if (set["weekday"]) {
                                    set["weekday"] = loc.getWeekday(set["weekday"]);
                                    if (set["shift"] && !set["unit"]) set["unit"] = loc["units"][5];
                                }
                                if (set["day"] && (tmp = loc.modifiersByName[set["day"]])) {
                                    set["day"] = tmp.value;
                                    d.reset();
                                    relative = true;
                                } else if (set["day"] && (weekday = loc.getWeekday(set["day"])) > -1) {
                                    delete set["day"];
                                    if (set["num"] && set["month"]) {
                                        afterDateSet(setWeekdayOfMonth);
                                        set["day"] = 1;
                                    } else {
                                        set["weekday"] = weekday;
                                    }
                                }
                                if (set["date"] && !isNumber(set["date"])) {
                                    set["date"] = loc.getNumericDate(set["date"]);
                                }
                                if (loc.matchPM(set["ampm"]) && set["hour"] < 12) {
                                    set["hour"] += 12;
                                } else if (loc.matchAM(set["ampm"]) && set["hour"] === 12) {
                                    set["hour"] = 0;
                                }
                                if ("offset_hours" in set || "offset_minutes" in set) {
                                    d.utc();
                                    set["offset_minutes"] = set["offset_minutes"] || 0;
                                    set["offset_minutes"] += set["offset_hours"] * 60;
                                    if (set["offset_sign"] === "-") {
                                        set["offset_minutes"] *= -1;
                                    }
                                    set["minute"] -= set["offset_minutes"];
                                }
                                if (set["unit"]) {
                                    relative = true;
                                    num = loc.getNumber(set["num"]);
                                    unitIndex = loc.getUnitIndex(set["unit"]);
                                    unit = English["units"][unitIndex];
                                    separateAbsoluteUnits();
                                    if (set["shift"]) {
                                        num *= (tmp = loc.modifiersByName[set["shift"]]) ? tmp.value : 0;
                                    }
                                    if (set["sign"] && (tmp = loc.modifiersByName[set["sign"]])) {
                                        num *= tmp.value;
                                    }
                                    if (isDefined(set["weekday"])) {
                                        d.set({
                                            weekday: set["weekday"]
                                        }, true);
                                        delete set["weekday"];
                                    }
                                    set[unit] = (set[unit] || 0) + num;
                                }
                                if (set["edge"]) {
                                    afterDateSet(setUnitEdge);
                                }
                                if (set["year_sign"] === "-") {
                                    set["year"] *= -1;
                                }
                                iterateOverDateUnits(function(name, unit, i) {
                                    var value = set[name], fraction = value % 1;
                                    if (fraction) {
                                        set[DateUnitsReversed[i - 1].name] = round(fraction * (name === "second" ? 1e3 : 60));
                                        set[name] = floor(value);
                                    }
                                }, 1, 4);
                                return false;
                            }
                        });
                    }
                    if (!set) {
                        if (f !== "now") {
                            d = new date(f);
                        }
                        if (forceUTC) {
                            d.addMinutes(-d.getTimezoneOffset());
                        }
                    } else if (relative) {
                        d.advance(set);
                    } else {
                        if (d._utc) {
                            d.reset();
                        }
                        updateDate(d, set, true, false, prefer);
                    }
                    fireCallbacks();
                    d.utc(false);
                }
                return {
                    date: d,
                    set: set
                };
            }
            function getYearFromAbbreviation(year) {
                return round(callDateGet(getNewDate(), "FullYear") / 100) * 100 - round(year / 100) * 100 + year;
            }
            function getShortHour(d) {
                var hours = callDateGet(d, "Hours");
                return hours === 0 ? 12 : hours - floor(hours / 13) * 12;
            }
            function getWeekNumber(date) {
                date = date.clone();
                var dow = callDateGet(date, "Day") || 7;
                date.addDays(4 - dow).reset();
                return 1 + floor(date.daysSince(date.clone().beginningOfYear()) / 7);
            }
            function getAdjustedUnit(ms) {
                var next, ams = abs(ms), value = ams, unitIndex = 0;
                iterateOverDateUnits(function(name, unit, i) {
                    next = floor(withPrecision(ams / unit.multiplier(), 1));
                    if (next >= 1) {
                        value = next;
                        unitIndex = i;
                    }
                }, 1);
                return [ value, unitIndex, ms ];
            }
            function getRelativeWithMonthFallback(date) {
                var adu = getAdjustedUnit(date.millisecondsFromNow());
                if (allowMonthFallback(date, adu)) {
                    adu[0] = abs(date.monthsFromNow());
                    adu[1] = 6;
                }
                return adu;
            }
            function allowMonthFallback(date, adu) {
                return adu[1] === 6 || adu[1] === 5 && adu[0] === 4 && date.daysFromNow() >= getNewDate().daysInMonth();
            }
            function createMeridianTokens(slice, caps) {
                var fn = function(d, localeCode) {
                    var hours = callDateGet(d, "Hours");
                    return getLocalization(localeCode)["ampm"][floor(hours / 12)] || "";
                };
                createFormatToken("t", fn, 1);
                createFormatToken("tt", fn);
                createFormatToken("T", fn, 1, 1);
                createFormatToken("TT", fn, null, 2);
            }
            function createWeekdayTokens(slice, caps) {
                var fn = function(d, localeCode) {
                    var dow = callDateGet(d, "Day");
                    return getLocalization(localeCode)["weekdays"][dow];
                };
                createFormatToken("dow", fn, 3);
                createFormatToken("Dow", fn, 3, 1);
                createFormatToken("weekday", fn);
                createFormatToken("Weekday", fn, null, 1);
            }
            function createMonthTokens(slice, caps) {
                createMonthToken("mon", 0, 3);
                createMonthToken("month", 0);
                createMonthToken("month2", 1);
                createMonthToken("month3", 2);
            }
            function createMonthToken(token, multiplier, slice) {
                var fn = function(d, localeCode) {
                    var month = callDateGet(d, "Month");
                    return getLocalization(localeCode)["months"][month + multiplier * 12];
                };
                createFormatToken(token, fn, slice);
                createFormatToken(simpleCapitalize(token), fn, slice, 1);
            }
            function createFormatToken(t, fn, slice, caps) {
                DateFormatTokens[t] = function(d, localeCode) {
                    var str = fn(d, localeCode);
                    if (slice) str = str.slice(0, slice);
                    if (caps) str = str.slice(0, caps).toUpperCase() + str.slice(caps);
                    return str;
                };
            }
            function createPaddedToken(t, fn, ms) {
                DateFormatTokens[t] = fn;
                DateFormatTokens[t + t] = function(d, localeCode) {
                    return padNumber(fn(d, localeCode), 2);
                };
                if (ms) {
                    DateFormatTokens[t + t + t] = function(d, localeCode) {
                        return padNumber(fn(d, localeCode), 3);
                    };
                    DateFormatTokens[t + t + t + t] = function(d, localeCode) {
                        return padNumber(fn(d, localeCode), 4);
                    };
                }
            }
            function buildCompiledOutputFormat(format) {
                var match = format.match(/(\{\w+\})|[^{}]+/g);
                CompiledOutputFormats[format] = match.map(function(p) {
                    p.replace(/\{(\w+)\}/, function(full, token) {
                        p = DateFormatTokens[token] || token;
                        return token;
                    });
                    return p;
                });
            }
            function executeCompiledOutputFormat(date, format, localeCode) {
                var compiledFormat, length, i, t, result = "";
                compiledFormat = CompiledOutputFormats[format];
                for (i = 0, length = compiledFormat.length; i < length; i++) {
                    t = compiledFormat[i];
                    result += isFunction(t) ? t(date, localeCode) : t;
                }
                return result;
            }
            function formatDate(date, format, relative, localeCode) {
                var adu;
                if (!date.isValid()) {
                    return "Invalid Date";
                } else if (Date[format]) {
                    format = Date[format];
                } else if (isFunction(format)) {
                    adu = getRelativeWithMonthFallback(date);
                    format = format.apply(date, adu.concat(getLocalization(localeCode)));
                }
                if (!format && relative) {
                    adu = adu || getRelativeWithMonthFallback(date);
                    if (adu[1] === 0) {
                        adu[1] = 1;
                        adu[0] = 1;
                    }
                    return getLocalization(localeCode).getRelativeFormat(adu);
                }
                format = format || "long";
                if (format === "short" || format === "long" || format === "full") {
                    format = getLocalization(localeCode)[format];
                }
                if (!CompiledOutputFormats[format]) {
                    buildCompiledOutputFormat(format);
                }
                return executeCompiledOutputFormat(date, format, localeCode);
            }
            function compareDate(d, find, localeCode, buffer, forceUTC) {
                var p, t, min, max, override, capitalized, accuracy = 0, loBuffer = 0, hiBuffer = 0;
                p = getExtendedDate(find, localeCode, null, forceUTC);
                if (buffer > 0) {
                    loBuffer = hiBuffer = buffer;
                    override = true;
                }
                if (!p.date.isValid()) return false;
                if (p.set && p.set.specificity) {
                    DateUnits.forEach(function(u, i) {
                        if (u.name === p.set.specificity) {
                            accuracy = u.multiplier(p.date, d - p.date) - 1;
                        }
                    });
                    capitalized = simpleCapitalize(p.set.specificity);
                    if (p.set["edge"] || p.set["shift"]) {
                        p.date["beginningOf" + capitalized]();
                    }
                    if (p.set.specificity === "month") {
                        max = p.date.clone()["endOf" + capitalized]().getTime();
                    }
                    if (!override && p.set["sign"] && p.set.specificity != "millisecond") {
                        loBuffer = 50;
                        hiBuffer = -50;
                    }
                }
                t = d.getTime();
                min = p.date.getTime();
                max = max || min + accuracy;
                max = compensateForTimezoneTraversal(d, min, max);
                return t >= min - loBuffer && t <= max + hiBuffer;
            }
            function compensateForTimezoneTraversal(d, min, max) {
                var dMin, dMax, minOffset, maxOffset;
                dMin = new date(min);
                dMax = new date(max).utc(d.isUTC());
                if (callDateGet(dMax, "Hours") !== 23) {
                    minOffset = dMin.getTimezoneOffset();
                    maxOffset = dMax.getTimezoneOffset();
                    if (minOffset !== maxOffset) {
                        max += (maxOffset - minOffset).minutes();
                    }
                }
                return max;
            }
            function updateDate(d, params, reset, advance, prefer) {
                var weekday, specificityIndex;
                function getParam(key) {
                    return isDefined(params[key]) ? params[key] : params[key + "s"];
                }
                function paramExists(key) {
                    return isDefined(getParam(key));
                }
                function uniqueParamExists(key, isDay) {
                    return paramExists(key) || isDay && paramExists("weekday");
                }
                function canDisambiguate() {
                    switch (prefer) {
                      case -1:
                        return d > getNewDate();

                      case 1:
                        return d < getNewDate();
                    }
                }
                if (isNumber(params) && advance) {
                    params = {
                        milliseconds: params
                    };
                } else if (isNumber(params)) {
                    d.setTime(params);
                    return d;
                }
                if (isDefined(params["date"])) {
                    params["day"] = params["date"];
                }
                iterateOverDateUnits(function(name, unit, i) {
                    var isDay = name === "day";
                    if (uniqueParamExists(name, isDay)) {
                        params.specificity = name;
                        specificityIndex = +i;
                        return false;
                    } else if (reset && name !== "week" && (!isDay || !paramExists("week"))) {
                        callDateSet(d, unit.method, isDay ? 1 : 0);
                    }
                });
                DateUnits.forEach(function(u, i) {
                    var name = u.name, method = u.method, higherUnit = DateUnits[i - 1], value;
                    value = getParam(name);
                    if (isUndefined(value)) return;
                    if (advance) {
                        if (name === "week") {
                            value = (params["day"] || 0) + value * 7;
                            method = "Date";
                        }
                        value = value * advance + callDateGet(d, method);
                    } else if (name === "month" && paramExists("day")) {
                        callDateSet(d, "Date", 15);
                    }
                    callDateSet(d, method, value);
                    if (advance && name === "month") {
                        checkMonthTraversal(d, value);
                    }
                });
                if (!advance && !paramExists("day") && paramExists("weekday")) {
                    var weekday = getParam("weekday"), isAhead, futurePreferred;
                    d.setWeekday(weekday);
                }
                if (canDisambiguate()) {
                    iterateOverDateUnits(function(name, unit) {
                        var ambiguous = unit.ambiguous || name === "week" && paramExists("weekday");
                        if (ambiguous && !uniqueParamExists(name, name === "day")) {
                            d[unit.addMethod](prefer);
                            return false;
                        }
                    }, specificityIndex + 1);
                }
                return d;
            }
            function prepareTime(format, loc, iso) {
                var timeSuffixMapping = {
                    h: 0,
                    m: 1,
                    s: 2
                }, add;
                loc = loc || English;
                return format.replace(/{([a-z])}/g, function(full, token) {
                    var separators = [], isHours = token === "h", tokenIsRequired = isHours && !iso;
                    if (token === "t") {
                        return loc["ampm"].join("|");
                    } else {
                        if (isHours) {
                            separators.push(":");
                        }
                        if (add = loc["timeSuffixes"][timeSuffixMapping[token]]) {
                            separators.push(add + "\\s*");
                        }
                        return separators.length === 0 ? "" : "(?:" + separators.join("|") + ")" + (tokenIsRequired ? "" : "?");
                    }
                });
            }
            function checkMonthTraversal(date, targetMonth) {
                if (targetMonth < 0) {
                    targetMonth = targetMonth % 12 + 12;
                }
                if (targetMonth % 12 != callDateGet(date, "Month")) {
                    callDateSet(date, "Date", 0);
                }
            }
            function createDate(args, prefer, forceUTC) {
                var f, localeCode;
                if (isNumber(args[1])) {
                    f = collectDateArguments(args)[0];
                } else {
                    f = args[0];
                    localeCode = args[1];
                }
                return getExtendedDate(f, localeCode, prefer, forceUTC).date;
            }
            function invalidateDate(d) {
                d.setTime(NaN);
            }
            function buildDateUnits() {
                DateUnitsReversed = DateUnits.concat().reverse();
                DateArgumentUnits = DateUnits.concat();
                DateArgumentUnits.splice(2, 1);
            }
            function buildDateMethods() {
                extendSimilar(date, true, true, DateUnits, function(methods, u, i) {
                    var name = u.name, caps = simpleCapitalize(name), multiplier = u.multiplier(), since, until;
                    u.addMethod = "add" + caps + "s";
                    function applyErrorMargin(ms) {
                        var num = ms / multiplier, fraction = num % 1, error = u.error || .999;
                        if (fraction && abs(fraction % 1) > error) {
                            num = round(num);
                        }
                        return num < 0 ? ceil(num) : floor(num);
                    }
                    since = function(f, localeCode) {
                        return applyErrorMargin(this.getTime() - date.create(f, localeCode).getTime());
                    };
                    until = function(f, localeCode) {
                        return applyErrorMargin(date.create(f, localeCode).getTime() - this.getTime());
                    };
                    methods[name + "sAgo"] = until;
                    methods[name + "sUntil"] = until;
                    methods[name + "sSince"] = since;
                    methods[name + "sFromNow"] = since;
                    methods[u.addMethod] = function(num, reset) {
                        var set = {};
                        set[name] = num;
                        return this.advance(set, reset);
                    };
                    buildNumberToDateAlias(u, multiplier);
                    if (i < 3) {
                        [ "Last", "This", "Next" ].forEach(function(shift) {
                            methods["is" + shift + caps] = function() {
                                return compareDate(this, shift + " " + name, "en");
                            };
                        });
                    }
                    if (i < 4) {
                        methods["beginningOf" + caps] = function() {
                            var set = {};
                            switch (name) {
                              case "year":
                                set["year"] = callDateGet(this, "FullYear");
                                break;

                              case "month":
                                set["month"] = callDateGet(this, "Month");
                                break;

                              case "day":
                                set["day"] = callDateGet(this, "Date");
                                break;

                              case "week":
                                set["weekday"] = 0;
                                break;
                            }
                            return this.set(set, true);
                        };
                        methods["endOf" + caps] = function() {
                            var set = {
                                hours: 23,
                                minutes: 59,
                                seconds: 59,
                                milliseconds: 999
                            };
                            switch (name) {
                              case "year":
                                set["month"] = 11;
                                set["day"] = 31;
                                break;

                              case "month":
                                set["day"] = this.daysInMonth();
                                break;

                              case "week":
                                set["weekday"] = 6;
                                break;
                            }
                            return this.set(set, true);
                        };
                    }
                });
            }
            function buildCoreInputFormats() {
                English.addFormat("([+-])?(\\d{4,4})[-.]?{full_month}[-.]?(\\d{1,2})?", true, [ "year_sign", "year", "month", "date" ], false, true);
                English.addFormat("(\\d{1,2})[-.\\/]{full_month}(?:[-.\\/](\\d{2,4}))?", true, [ "date", "month", "year" ], true);
                English.addFormat("{full_month}[-.](\\d{4,4})", false, [ "month", "year" ]);
                English.addFormat("\\/Date\\((\\d+(?:[+-]\\d{4,4})?)\\)\\/", false, [ "timestamp" ]);
                English.addFormat(prepareTime(RequiredTime, English), false, TimeFormat);
                CoreDateFormats = English.compiledFormats.slice(0, 7).reverse();
                English.compiledFormats = English.compiledFormats.slice(7).concat(CoreDateFormats);
            }
            function buildFormatTokens() {
                createPaddedToken("f", function(d) {
                    return callDateGet(d, "Milliseconds");
                }, true);
                createPaddedToken("s", function(d) {
                    return callDateGet(d, "Seconds");
                });
                createPaddedToken("m", function(d) {
                    return callDateGet(d, "Minutes");
                });
                createPaddedToken("h", function(d) {
                    return callDateGet(d, "Hours") % 12 || 12;
                });
                createPaddedToken("H", function(d) {
                    return callDateGet(d, "Hours");
                });
                createPaddedToken("d", function(d) {
                    return callDateGet(d, "Date");
                });
                createPaddedToken("M", function(d) {
                    return callDateGet(d, "Month") + 1;
                });
                createMeridianTokens();
                createWeekdayTokens();
                createMonthTokens();
                DateFormatTokens["ms"] = DateFormatTokens["f"];
                DateFormatTokens["milliseconds"] = DateFormatTokens["f"];
                DateFormatTokens["seconds"] = DateFormatTokens["s"];
                DateFormatTokens["minutes"] = DateFormatTokens["m"];
                DateFormatTokens["hours"] = DateFormatTokens["h"];
                DateFormatTokens["24hr"] = DateFormatTokens["H"];
                DateFormatTokens["12hr"] = DateFormatTokens["h"];
                DateFormatTokens["date"] = DateFormatTokens["d"];
                DateFormatTokens["day"] = DateFormatTokens["d"];
                DateFormatTokens["year"] = DateFormatTokens["yyyy"];
            }
            function buildFormatShortcuts() {
                extendSimilar(date, true, true, "short,long,full", function(methods, name) {
                    methods[name] = function(localeCode) {
                        return formatDate(this, name, false, localeCode);
                    };
                });
            }
            function buildAsianDigits() {
                KanjiDigits.split("").forEach(function(digit, value) {
                    var holder;
                    if (value > 9) {
                        value = pow(10, value - 9);
                    }
                    AsianDigitMap[digit] = value;
                });
                simpleMerge(AsianDigitMap, NumberNormalizeMap);
                AsianDigitReg = regexp("([期週周])?([" + KanjiDigits + FullWidthDigits + "]+)(?!昨)", "g");
            }
            function buildRelativeAliases() {
                var special = "today,yesterday,tomorrow,weekday,weekend,future,past".split(",");
                var weekdays = English["weekdays"].slice(0, 7);
                var months = English["months"].slice(0, 12);
                extendSimilar(date, true, true, special.concat(weekdays).concat(months), function(methods, name) {
                    methods["is" + simpleCapitalize(name)] = function(utc) {
                        return this.is(name, 0, utc);
                    };
                });
            }
            function buildUTCAliases() {
                if (date["utc"]) return;
                date["utc"] = {
                    create: function() {
                        return createDate(arguments, 0, true);
                    },
                    past: function() {
                        return createDate(arguments, -1, true);
                    },
                    future: function() {
                        return createDate(arguments, 1, true);
                    }
                };
            }
            function setDateProperties() {
                extend(date, false, true, {
                    RFC1123: "{Dow}, {dd} {Mon} {yyyy} {HH}:{mm}:{ss} {tz}",
                    RFC1036: "{Weekday}, {dd}-{Mon}-{yy} {HH}:{mm}:{ss} {tz}",
                    ISO8601_DATE: "{yyyy}-{MM}-{dd}",
                    ISO8601_DATETIME: "{yyyy}-{MM}-{dd}T{HH}:{mm}:{ss}.{fff}{isotz}"
                });
            }
            extend(date, false, true, {
                create: function() {
                    return createDate(arguments);
                },
                past: function() {
                    return createDate(arguments, -1);
                },
                future: function() {
                    return createDate(arguments, 1);
                },
                addLocale: function(localeCode, set) {
                    return setLocalization(localeCode, set);
                },
                setLocale: function(localeCode, set) {
                    var loc = getLocalization(localeCode, false);
                    CurrentLocalization = loc;
                    if (localeCode && localeCode != loc["code"]) {
                        loc["code"] = localeCode;
                    }
                    return loc;
                },
                getLocale: function(localeCode) {
                    return !localeCode ? CurrentLocalization : getLocalization(localeCode, false);
                },
                addFormat: function(format, match, localeCode) {
                    addDateInputFormat(getLocalization(localeCode), format, match);
                }
            });
            extend(date, true, true, {
                set: function() {
                    var args = collectDateArguments(arguments);
                    return updateDate(this, args[0], args[1]);
                },
                setWeekday: function(dow) {
                    if (isUndefined(dow)) return;
                    return callDateSet(this, "Date", callDateGet(this, "Date") + dow - callDateGet(this, "Day"));
                },
                setISOWeek: function(week) {
                    var weekday = callDateGet(this, "Day") || 7;
                    if (isUndefined(week)) return;
                    this.set({
                        month: 0,
                        date: 4
                    });
                    this.set({
                        weekday: 1
                    });
                    if (week > 1) {
                        this.addWeeks(week - 1);
                    }
                    if (weekday !== 1) {
                        this.advance({
                            days: weekday - 1
                        });
                    }
                    return this.getTime();
                },
                getISOWeek: function() {
                    return getWeekNumber(this);
                },
                beginningOfISOWeek: function() {
                    var day = this.getDay();
                    if (day === 0) {
                        day = -6;
                    } else if (day !== 1) {
                        day = 1;
                    }
                    this.setWeekday(day);
                    return this.reset();
                },
                endOfISOWeek: function() {
                    if (this.getDay() !== 0) {
                        this.setWeekday(7);
                    }
                    return this.endOfDay();
                },
                getUTCOffset: function(iso) {
                    var offset = this._utc ? 0 : this.getTimezoneOffset();
                    var colon = iso === true ? ":" : "";
                    if (!offset && iso) return "Z";
                    return padNumber(floor(-offset / 60), 2, true) + colon + padNumber(abs(offset % 60), 2);
                },
                utc: function(set) {
                    defineProperty(this, "_utc", set === true || arguments.length === 0);
                    return this;
                },
                isUTC: function() {
                    return !!this._utc || this.getTimezoneOffset() === 0;
                },
                advance: function() {
                    var args = collectDateArguments(arguments, true);
                    return updateDate(this, args[0], args[1], 1);
                },
                rewind: function() {
                    var args = collectDateArguments(arguments, true);
                    return updateDate(this, args[0], args[1], -1);
                },
                isValid: function() {
                    return !isNaN(this.getTime());
                },
                isAfter: function(d, margin, utc) {
                    return this.getTime() > date.create(d).getTime() - (margin || 0);
                },
                isBefore: function(d, margin) {
                    return this.getTime() < date.create(d).getTime() + (margin || 0);
                },
                isBetween: function(d1, d2, margin) {
                    var t = this.getTime();
                    var t1 = date.create(d1).getTime();
                    var t2 = date.create(d2).getTime();
                    var lo = min(t1, t2);
                    var hi = max(t1, t2);
                    margin = margin || 0;
                    return lo - margin < t && hi + margin > t;
                },
                isLeapYear: function() {
                    var year = callDateGet(this, "FullYear");
                    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                },
                daysInMonth: function() {
                    return 32 - callDateGet(new date(callDateGet(this, "FullYear"), callDateGet(this, "Month"), 32), "Date");
                },
                format: function(f, localeCode) {
                    return formatDate(this, f, false, localeCode);
                },
                relative: function(fn, localeCode) {
                    if (isString(fn)) {
                        localeCode = fn;
                        fn = null;
                    }
                    return formatDate(this, fn, true, localeCode);
                },
                is: function(d, margin, utc) {
                    var tmp, comp;
                    if (!this.isValid()) return;
                    if (isString(d)) {
                        d = d.trim().toLowerCase();
                        comp = this.clone().utc(utc);
                        switch (true) {
                          case d === "future":
                            return this.getTime() > getNewDate().getTime();

                          case d === "past":
                            return this.getTime() < getNewDate().getTime();

                          case d === "weekday":
                            return callDateGet(comp, "Day") > 0 && callDateGet(comp, "Day") < 6;

                          case d === "weekend":
                            return callDateGet(comp, "Day") === 0 || callDateGet(comp, "Day") === 6;

                          case (tmp = English["weekdays"].indexOf(d) % 7) > -1:
                            return callDateGet(comp, "Day") === tmp;

                          case (tmp = English["months"].indexOf(d) % 12) > -1:
                            return callDateGet(comp, "Month") === tmp;
                        }
                    }
                    return compareDate(this, d, null, margin, utc);
                },
                reset: function(unit) {
                    var params = {}, recognized;
                    unit = unit || "hours";
                    if (unit === "date") unit = "days";
                    recognized = DateUnits.some(function(u) {
                        return unit === u.name || unit === u.name + "s";
                    });
                    params[unit] = unit.match(/^days?/) ? 1 : 0;
                    return recognized ? this.set(params, true) : this;
                },
                clone: function() {
                    var d = new date(this.getTime());
                    d.utc(!!this._utc);
                    return d;
                }
            });
            extend(date, true, true, {
                iso: function() {
                    return this.toISOString();
                },
                getWeekday: date.prototype.getDay,
                getUTCWeekday: date.prototype.getUTCDay
            });
            function buildNumberToDateAlias(u, multiplier) {
                var name = u.name, methods = {};
                function base() {
                    return round(this * multiplier);
                }
                function after() {
                    return createDate(arguments)[u.addMethod](this);
                }
                function before() {
                    return createDate(arguments)[u.addMethod](-this);
                }
                methods[name] = base;
                methods[name + "s"] = base;
                methods[name + "Before"] = before;
                methods[name + "sBefore"] = before;
                methods[name + "Ago"] = before;
                methods[name + "sAgo"] = before;
                methods[name + "After"] = after;
                methods[name + "sAfter"] = after;
                methods[name + "FromNow"] = after;
                methods[name + "sFromNow"] = after;
                number.extend(methods);
            }
            extend(number, true, true, {
                duration: function(localeCode) {
                    return getLocalization(localeCode).getDuration(this);
                }
            });
            English = CurrentLocalization = date.addLocale("en", {
                plural: true,
                timeMarker: "at",
                ampm: "am,pm",
                months: "January,February,March,April,May,June,July,August,September,October,November,December",
                weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday",
                units: "millisecond:|s,second:|s,minute:|s,hour:|s,day:|s,week:|s,month:|s,year:|s",
                numbers: "one,two,three,four,five,six,seven,eight,nine,ten",
                articles: "a,an,the",
                tokens: "the,st|nd|rd|th,of",
                "short": "{Month} {d}, {yyyy}",
                "long": "{Month} {d}, {yyyy} {h}:{mm}{tt}",
                full: "{Weekday} {Month} {d}, {yyyy} {h}:{mm}:{ss}{tt}",
                past: "{num} {unit} {sign}",
                future: "{num} {unit} {sign}",
                duration: "{num} {unit}",
                modifiers: [ {
                    name: "sign",
                    src: "ago|before",
                    value: -1
                }, {
                    name: "sign",
                    src: "from now|after|from|in|later",
                    value: 1
                }, {
                    name: "edge",
                    src: "last day",
                    value: -2
                }, {
                    name: "edge",
                    src: "end",
                    value: -1
                }, {
                    name: "edge",
                    src: "first day|beginning",
                    value: 1
                }, {
                    name: "shift",
                    src: "last",
                    value: -1
                }, {
                    name: "shift",
                    src: "the|this",
                    value: 0
                }, {
                    name: "shift",
                    src: "next",
                    value: 1
                } ],
                dateParse: [ "{month} {year}", "{shift} {unit=5-7}", "{0?} {date}{1}", "{0?} {edge} of {shift?} {unit=4-7?}{month?}{year?}" ],
                timeParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{0} {num}{1} {day} of {month} {year?}", "{weekday?} {month} {date}{1?} {year?}", "{date} {month} {year}", "{date} {month}", "{shift} {weekday}", "{shift} week {weekday}", "{weekday} {2?} {shift} week", "{num} {unit=4-5} {sign} {day}", "{0?} {date}{1} of {month}", "{0?}{month?} {date?}{1?} of {shift} {unit=6-7}" ]
            });
            buildDateUnits();
            buildDateMethods();
            buildCoreInputFormats();
            buildFormatTokens();
            buildFormatShortcuts();
            buildAsianDigits();
            buildRelativeAliases();
            buildUTCAliases();
            setDateProperties();
            function Range(start, end) {
                this.start = cloneRangeMember(start);
                this.end = cloneRangeMember(end);
            }
            function getRangeMemberNumericValue(m) {
                return isString(m) ? m.charCodeAt(0) : m;
            }
            function getRangeMemberPrimitiveValue(m) {
                if (m == null) return m;
                return isDate(m) ? m.getTime() : m.valueOf();
            }
            function cloneRangeMember(m) {
                if (isDate(m)) {
                    return new date(m.getTime());
                } else {
                    return getRangeMemberPrimitiveValue(m);
                }
            }
            function isValidRangeMember(m) {
                var val = getRangeMemberPrimitiveValue(m);
                return !!val || val === 0;
            }
            function getDuration(amt) {
                var match, val, unit;
                if (isNumber(amt)) {
                    return amt;
                }
                match = amt.toLowerCase().match(/^(\d+)?\s?(\w+?)s?$/i);
                val = parseInt(match[1]) || 1;
                unit = match[2].slice(0, 1).toUpperCase() + match[2].slice(1);
                if (unit.match(/hour|minute|second/i)) {
                    unit += "s";
                } else if (unit === "Year") {
                    unit = "FullYear";
                } else if (unit === "Day") {
                    unit = "Date";
                }
                return [ val, unit ];
            }
            function incrementDate(current, amount) {
                var num, unit, val, d;
                if (isNumber(amount)) {
                    return new date(current.getTime() + amount);
                }
                num = amount[0];
                unit = amount[1];
                val = callDateGet(current, unit);
                d = new date(current.getTime());
                callDateSet(d, unit, val + num);
                return d;
            }
            function incrementString(current, amount) {
                return string.fromCharCode(current.charCodeAt(0) + amount);
            }
            function incrementNumber(current, amount) {
                return current + amount;
            }
            Range.prototype.toString = function() {
                return this.isValid() ? this.start + ".." + this.end : "Invalid Range";
            };
            extend(Range, true, true, {
                isValid: function() {
                    return isValidRangeMember(this.start) && isValidRangeMember(this.end) && typeof this.start === typeof this.end;
                },
                span: function() {
                    return this.isValid() ? abs(getRangeMemberNumericValue(this.end) - getRangeMemberNumericValue(this.start)) + 1 : NaN;
                },
                contains: function(obj) {
                    var self = this, arr;
                    if (obj == null) return false;
                    if (obj.start && obj.end) {
                        return obj.start >= this.start && obj.start <= this.end && obj.end >= this.start && obj.end <= this.end;
                    } else {
                        return obj >= this.start && obj <= this.end;
                    }
                },
                every: function(amount, fn) {
                    var increment, start = this.start, end = this.end, inverse = end < start, current = start, index = 0, result = [];
                    if (isFunction(amount)) {
                        fn = amount;
                        amount = null;
                    }
                    amount = amount || 1;
                    if (isNumber(start)) {
                        increment = incrementNumber;
                    } else if (isString(start)) {
                        increment = incrementString;
                    } else if (isDate(start)) {
                        amount = getDuration(amount);
                        increment = incrementDate;
                    }
                    if (inverse && amount > 0) {
                        amount *= -1;
                    }
                    while (inverse ? current >= end : current <= end) {
                        result.push(current);
                        if (fn) {
                            fn(current, index);
                        }
                        current = increment(current, amount);
                        index++;
                    }
                    return result;
                },
                union: function(range) {
                    return new Range(this.start < range.start ? this.start : range.start, this.end > range.end ? this.end : range.end);
                },
                intersect: function(range) {
                    if (range.start > this.end || range.end < this.start) {
                        return new Range(NaN, NaN);
                    }
                    return new Range(this.start > range.start ? this.start : range.start, this.end < range.end ? this.end : range.end);
                },
                clone: function(range) {
                    return new Range(this.start, this.end);
                },
                clamp: function(obj) {
                    var clamped, start = this.start, end = this.end, min = end < start ? end : start, max = start > end ? start : end;
                    if (obj < min) {
                        clamped = min;
                    } else if (obj > max) {
                        clamped = max;
                    } else {
                        clamped = obj;
                    }
                    return cloneRangeMember(clamped);
                }
            });
            [ number, string, date ].forEach(function(klass) {
                extend(klass, false, true, {
                    range: function(start, end) {
                        if (klass.create) {
                            start = klass.create(start);
                            end = klass.create(end);
                        }
                        return new Range(start, end);
                    }
                });
            });
            extend(number, true, true, {
                upto: function(num, fn, step) {
                    return number.range(this, num).every(step, fn);
                },
                clamp: function(start, end) {
                    return new Range(start, end).clamp(this);
                },
                cap: function(max) {
                    return this.clamp(Undefined, max);
                }
            });
            extend(number, true, true, {
                downto: number.prototype.upto
            });
            extend(array, false, function(a) {
                return a instanceof Range;
            }, {
                create: function(range) {
                    return range.every();
                }
            });
            function setDelay(fn, ms, after, scope, args) {
                if (ms === Infinity) return;
                if (!fn.timers) fn.timers = [];
                if (!isNumber(ms)) ms = 1;
                fn._canceled = false;
                fn.timers.push(setTimeout(function() {
                    if (!fn._canceled) {
                        after.apply(scope, args || []);
                    }
                }, ms));
            }
            extend(Function, true, true, {
                lazy: function(ms, immediate, limit) {
                    var fn = this, queue = [], locked = false, execute, rounded, perExecution, result;
                    ms = ms || 1;
                    limit = limit || Infinity;
                    rounded = ceil(ms);
                    perExecution = round(rounded / ms) || 1;
                    execute = function() {
                        var queueLength = queue.length, maxPerRound;
                        if (queueLength == 0) return;
                        maxPerRound = max(queueLength - perExecution, 0);
                        while (queueLength > maxPerRound) {
                            result = Function.prototype.apply.apply(fn, queue.shift());
                            queueLength--;
                        }
                        setDelay(lazy, rounded, function() {
                            locked = false;
                            execute();
                        });
                    };
                    function lazy() {
                        if (queue.length < limit - (locked && immediate ? 1 : 0)) {
                            queue.push([ this, arguments ]);
                        }
                        if (!locked) {
                            locked = true;
                            if (immediate) {
                                execute();
                            } else {
                                setDelay(lazy, rounded, execute);
                            }
                        }
                        return result;
                    }
                    return lazy;
                },
                throttle: function(ms) {
                    return this.lazy(ms, true, 1);
                },
                debounce: function(ms) {
                    var fn = this;
                    function debounced() {
                        debounced.cancel();
                        setDelay(debounced, ms, fn, this, arguments);
                    }
                    return debounced;
                },
                delay: function(ms) {
                    var fn = this;
                    var args = multiArgs(arguments, null, 1);
                    setDelay(fn, ms, fn, fn, args);
                    return fn;
                },
                every: function(ms) {
                    var fn = this, args = arguments;
                    args = args.length > 1 ? multiArgs(args, null, 1) : [];
                    function execute() {
                        fn.apply(fn, args);
                        setDelay(fn, ms, execute);
                    }
                    setDelay(fn, ms, execute);
                    return fn;
                },
                cancel: function() {
                    var timers = this.timers, timer;
                    if (isArray(timers)) {
                        while (timer = timers.shift()) {
                            clearTimeout(timer);
                        }
                    }
                    this._canceled = true;
                    return this;
                },
                after: function(num) {
                    var fn = this, counter = 0, storedArguments = [];
                    if (!isNumber(num)) {
                        num = 1;
                    } else if (num === 0) {
                        fn.call();
                        return fn;
                    }
                    return function() {
                        var ret;
                        storedArguments.push(multiArgs(arguments));
                        counter++;
                        if (counter == num) {
                            ret = fn.call(this, storedArguments);
                            counter = 0;
                            storedArguments = [];
                            return ret;
                        }
                    };
                },
                once: function() {
                    return this.throttle(Infinity, true);
                },
                fill: function() {
                    var fn = this, curried = multiArgs(arguments);
                    return function() {
                        var args = multiArgs(arguments);
                        curried.forEach(function(arg, index) {
                            if (arg != null || index >= args.length) args.splice(index, 0, arg);
                        });
                        return fn.apply(this, args);
                    };
                }
            });
            function abbreviateNumber(num, roundTo, str, mid, limit, bytes) {
                var fixed = num.toFixed(20), decimalPlace = fixed.search(/\./), numeralPlace = fixed.search(/[1-9]/), significant = decimalPlace - numeralPlace, unit, i, divisor;
                if (significant > 0) {
                    significant -= 1;
                }
                i = max(min(floor(significant / 3), limit === false ? str.length : limit), -mid);
                unit = str.charAt(i + mid - 1);
                if (significant < -9) {
                    i = -3;
                    roundTo = abs(significant) - 9;
                    unit = str.slice(0, 1);
                }
                divisor = bytes ? pow(2, 10 * i) : pow(10, i * 3);
                return withPrecision(num / divisor, roundTo || 0).format() + unit.trim();
            }
            extend(number, false, true, {
                random: function(n1, n2) {
                    var minNum, maxNum;
                    if (arguments.length == 1) n2 = n1, n1 = 0;
                    minNum = min(n1 || 0, isUndefined(n2) ? 1 : n2);
                    maxNum = max(n1 || 0, isUndefined(n2) ? 1 : n2) + 1;
                    return floor(math.random() * (maxNum - minNum) + minNum);
                }
            });
            extend(number, true, true, {
                log: function(base) {
                    return math.log(this) / (base ? math.log(base) : 1);
                },
                abbr: function(precision) {
                    return abbreviateNumber(this, precision, "kmbt", 0, 4);
                },
                metric: function(precision, limit) {
                    return abbreviateNumber(this, precision, "nμm kMGTPE", 4, isUndefined(limit) ? 1 : limit);
                },
                bytes: function(precision, limit) {
                    return abbreviateNumber(this, precision, "kMGTPE", 0, isUndefined(limit) ? 4 : limit, true) + "B";
                },
                isInteger: function() {
                    return this % 1 == 0;
                },
                isOdd: function() {
                    return !isNaN(this) && !this.isMultipleOf(2);
                },
                isEven: function() {
                    return this.isMultipleOf(2);
                },
                isMultipleOf: function(num) {
                    return this % num === 0;
                },
                format: function(place, thousands, decimal) {
                    var i, str, split, integer, fraction, result = "";
                    if (isUndefined(thousands)) {
                        thousands = ",";
                    }
                    if (isUndefined(decimal)) {
                        decimal = ".";
                    }
                    str = (isNumber(place) ? withPrecision(this, place || 0).toFixed(max(place, 0)) : this.toString()).replace(/^-/, "");
                    split = str.split(".");
                    integer = split[0];
                    fraction = split[1];
                    for (i = integer.length; i > 0; i -= 3) {
                        if (i < integer.length) {
                            result = thousands + result;
                        }
                        result = integer.slice(max(0, i - 3), i) + result;
                    }
                    if (fraction) {
                        result += decimal + repeatString("0", (place || 0) - fraction.length) + fraction;
                    }
                    return (this < 0 ? "-" : "") + result;
                },
                hex: function(pad) {
                    return this.pad(pad || 1, false, 16);
                },
                times: function(fn) {
                    if (fn) {
                        for (var i = 0; i < this; i++) {
                            fn.call(this, i);
                        }
                    }
                    return this.toNumber();
                },
                chr: function() {
                    return string.fromCharCode(this);
                },
                pad: function(place, sign, base) {
                    return padNumber(this, place, sign, base);
                },
                ordinalize: function() {
                    var suffix, num = abs(this), last = parseInt(num.toString().slice(-2));
                    return this + getOrdinalizedSuffix(last);
                },
                toNumber: function() {
                    return parseFloat(this, 10);
                }
            });
            function buildNumber() {
                function createRoundingFunction(fn) {
                    return function(precision) {
                        return precision ? withPrecision(this, precision, fn) : fn(this);
                    };
                }
                extend(number, true, true, {
                    ceil: createRoundingFunction(ceil),
                    round: createRoundingFunction(round),
                    floor: createRoundingFunction(floor)
                });
                extendSimilar(number, true, true, "abs,pow,sin,asin,cos,acos,tan,atan,exp,pow,sqrt", function(methods, name) {
                    methods[name] = function(a, b) {
                        return math[name](this, a, b);
                    };
                });
            }
            buildNumber();
            var ObjectTypeMethods = "isObject,isNaN".split(",");
            var ObjectHashMethods = "keys,values,select,reject,each,merge,clone,equal,watch,tap,has,toQueryString".split(",");
            function setParamsObject(obj, param, value, castBoolean) {
                var reg = /^(.+?)(\[.*\])$/, paramIsArray, match, allKeys, key;
                if (match = param.match(reg)) {
                    key = match[1];
                    allKeys = match[2].replace(/^\[|\]$/g, "").split("][");
                    allKeys.forEach(function(k) {
                        paramIsArray = !k || k.match(/^\d+$/);
                        if (!key && isArray(obj)) key = obj.length;
                        if (!hasOwnProperty(obj, key)) {
                            obj[key] = paramIsArray ? [] : {};
                        }
                        obj = obj[key];
                        key = k;
                    });
                    if (!key && paramIsArray) key = obj.length.toString();
                    setParamsObject(obj, key, value, castBoolean);
                } else if (castBoolean && value === "true") {
                    obj[param] = true;
                } else if (castBoolean && value === "false") {
                    obj[param] = false;
                } else {
                    obj[param] = value;
                }
            }
            function objectToQueryString(base, obj) {
                var tmp;
                if (isArray(obj) || isObjectType(obj) && obj.toString === internalToString) {
                    tmp = [];
                    iterateOverObject(obj, function(key, value) {
                        if (base) {
                            key = base + "[" + key + "]";
                        }
                        tmp.push(objectToQueryString(key, value));
                    });
                    return tmp.join("&");
                } else {
                    if (!base) return "";
                    return sanitizeURIComponent(base) + "=" + (isDate(obj) ? obj.getTime() : sanitizeURIComponent(obj));
                }
            }
            function sanitizeURIComponent(obj) {
                return !obj && obj !== false && obj !== 0 ? "" : encodeURIComponent(obj).replace(/%20/g, "+");
            }
            function matchInObject(match, key, value) {
                if (isRegExp(match)) {
                    return match.test(key);
                } else if (isObjectType(match)) {
                    return match[key] === value;
                } else {
                    return key === string(match);
                }
            }
            function selectFromObject(obj, args, select) {
                var match, result = obj instanceof Hash ? new Hash() : {};
                iterateOverObject(obj, function(key, value) {
                    match = false;
                    flattenedArgs(args, function(arg) {
                        if (matchInObject(arg, key, value)) {
                            match = true;
                        }
                    }, 1);
                    if (match === select) {
                        result[key] = value;
                    }
                });
                return result;
            }
            function buildTypeMethods() {
                extendSimilar(object, false, true, ClassNames, function(methods, name) {
                    var method = "is" + name;
                    ObjectTypeMethods.push(method);
                    methods[method] = typeChecks[name];
                });
            }
            function buildObjectExtend() {
                extend(object, false, function() {
                    return arguments.length === 0;
                }, {
                    extend: function() {
                        var methods = ObjectTypeMethods.concat(ObjectHashMethods);
                        if (typeof EnumerableMethods !== "undefined") {
                            methods = methods.concat(EnumerableMethods);
                        }
                        buildObjectInstanceMethods(methods, object);
                    }
                });
            }
            extend(object, false, true, {
                watch: function(obj, prop, fn) {
                    if (!definePropertySupport) return;
                    var value = obj[prop];
                    object.defineProperty(obj, prop, {
                        enumerable: true,
                        configurable: true,
                        get: function() {
                            return value;
                        },
                        set: function(to) {
                            value = fn.call(obj, prop, value, to);
                        }
                    });
                }
            });
            extend(object, false, function() {
                return arguments.length > 1;
            }, {
                keys: function(obj, fn) {
                    var keys = object.keys(obj);
                    keys.forEach(function(key) {
                        fn.call(obj, key, obj[key]);
                    });
                    return keys;
                }
            });
            extend(object, false, true, {
                isObject: function(obj) {
                    return isPlainObject(obj);
                },
                isNaN: function(obj) {
                    return isNumber(obj) && obj.valueOf() !== obj.valueOf();
                },
                equal: function(a, b) {
                    return isEqual(a, b);
                },
                extended: function(obj) {
                    return new Hash(obj);
                },
                merge: function(target, source, deep, resolve) {
                    var key, sourceIsObject, targetIsObject, sourceVal, targetVal, conflict, result;
                    if (target && typeof source !== "string") {
                        for (key in source) {
                            if (!hasOwnProperty(source, key) || !target) continue;
                            sourceVal = source[key];
                            targetVal = target[key];
                            conflict = isDefined(targetVal);
                            sourceIsObject = isObjectType(sourceVal);
                            targetIsObject = isObjectType(targetVal);
                            result = conflict && resolve === false ? targetVal : sourceVal;
                            if (conflict) {
                                if (isFunction(resolve)) {
                                    result = resolve.call(source, key, targetVal, sourceVal);
                                }
                            }
                            if (deep && (sourceIsObject || targetIsObject)) {
                                if (isDate(sourceVal)) {
                                    result = new date(sourceVal.getTime());
                                } else if (isRegExp(sourceVal)) {
                                    result = new regexp(sourceVal.source, getRegExpFlags(sourceVal));
                                } else {
                                    if (!targetIsObject) target[key] = array.isArray(sourceVal) ? [] : {};
                                    object.merge(target[key], sourceVal, deep, resolve);
                                    continue;
                                }
                            }
                            target[key] = result;
                        }
                    }
                    return target;
                },
                values: function(obj, fn) {
                    var values = [];
                    iterateOverObject(obj, function(k, v) {
                        values.push(v);
                        if (fn) fn.call(obj, v);
                    });
                    return values;
                },
                clone: function(obj, deep) {
                    var target, klass;
                    if (!isObjectType(obj)) {
                        return obj;
                    }
                    klass = className(obj);
                    if (isDate(obj, klass) && obj.clone) {
                        return obj.clone();
                    } else if (isDate(obj, klass) || isRegExp(obj, klass)) {
                        return new obj.constructor(obj);
                    } else if (obj instanceof Hash) {
                        target = new Hash();
                    } else if (isArray(obj, klass)) {
                        target = [];
                    } else if (isPlainObject(obj, klass)) {
                        target = {};
                    } else {
                        throw new TypeError("Clone must be a basic data type.");
                    }
                    return object.merge(target, obj, deep);
                },
                fromQueryString: function(str, castBoolean) {
                    var result = object.extended(), split;
                    str = str && str.toString ? str.toString() : "";
                    str.replace(/^.*?\?/, "").split("&").forEach(function(p) {
                        var split = p.split("=");
                        if (split.length !== 2) return;
                        setParamsObject(result, split[0], decodeURIComponent(split[1]), castBoolean);
                    });
                    return result;
                },
                toQueryString: function(obj, namespace) {
                    return objectToQueryString(namespace, obj);
                },
                tap: function(obj, arg) {
                    var fn = arg;
                    if (!isFunction(arg)) {
                        fn = function() {
                            if (arg) obj[arg]();
                        };
                    }
                    fn.call(obj, obj);
                    return obj;
                },
                has: function(obj, key) {
                    return hasOwnProperty(obj, key);
                },
                select: function(obj) {
                    return selectFromObject(obj, arguments, true);
                },
                reject: function(obj) {
                    return selectFromObject(obj, arguments, false);
                }
            });
            buildTypeMethods();
            buildObjectExtend();
            buildObjectInstanceMethods(ObjectHashMethods, Hash);
            extend(regexp, false, true, {
                escape: function(str) {
                    return escapeRegExp(str);
                }
            });
            extend(regexp, true, true, {
                getFlags: function() {
                    return getRegExpFlags(this);
                },
                setFlags: function(flags) {
                    return regexp(this.source, flags);
                },
                addFlag: function(flag) {
                    return this.setFlags(getRegExpFlags(this, flag));
                },
                removeFlag: function(flag) {
                    return this.setFlags(getRegExpFlags(this).replace(flag, ""));
                }
            });
            function getAcronym(word) {
                var inflector = string.Inflector;
                var word = inflector && inflector.acronyms[word];
                if (isString(word)) {
                    return word;
                }
            }
            function checkRepeatRange(num) {
                num = +num;
                if (num < 0 || num === Infinity) {
                    throw new RangeError("Invalid number");
                }
                return num;
            }
            function padString(num, padding) {
                return repeatString(isDefined(padding) ? padding : " ", num);
            }
            function truncateString(str, length, from, ellipsis, split) {
                var str1, str2, len1, len2;
                if (str.length <= length) {
                    return str.toString();
                }
                ellipsis = isUndefined(ellipsis) ? "..." : ellipsis;
                switch (from) {
                  case "left":
                    str2 = split ? truncateOnWord(str, length, true) : str.slice(str.length - length);
                    return ellipsis + str2;

                  case "middle":
                    len1 = ceil(length / 2);
                    len2 = floor(length / 2);
                    str1 = split ? truncateOnWord(str, len1) : str.slice(0, len1);
                    str2 = split ? truncateOnWord(str, len2, true) : str.slice(str.length - len2);
                    return str1 + ellipsis + str2;

                  default:
                    str1 = split ? truncateOnWord(str, length) : str.slice(0, length);
                    return str1 + ellipsis;
                }
            }
            function truncateOnWord(str, limit, fromLeft) {
                if (fromLeft) {
                    return truncateOnWord(str.reverse(), limit).reverse();
                }
                var reg = regexp("(?=[" + getTrimmableCharacters() + "])");
                var words = str.split(reg);
                var count = 0;
                return words.filter(function(word) {
                    count += word.length;
                    return count <= limit;
                }).join("");
            }
            function numberOrIndex(str, n, from) {
                if (isString(n)) {
                    n = str.indexOf(n);
                    if (n === -1) {
                        n = from ? str.length : 0;
                    }
                }
                return n;
            }
            var btoa, atob;
            function buildBase64(key) {
                if (globalContext.btoa) {
                    btoa = globalContext.btoa;
                    atob = globalContext.atob;
                    return;
                }
                var base64reg = /[^A-Za-z0-9\+\/\=]/g;
                btoa = function(str) {
                    var output = "";
                    var chr1, chr2, chr3;
                    var enc1, enc2, enc3, enc4;
                    var i = 0;
                    do {
                        chr1 = str.charCodeAt(i++);
                        chr2 = str.charCodeAt(i++);
                        chr3 = str.charCodeAt(i++);
                        enc1 = chr1 >> 2;
                        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                        enc4 = chr3 & 63;
                        if (isNaN(chr2)) {
                            enc3 = enc4 = 64;
                        } else if (isNaN(chr3)) {
                            enc4 = 64;
                        }
                        output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);
                        chr1 = chr2 = chr3 = "";
                        enc1 = enc2 = enc3 = enc4 = "";
                    } while (i < str.length);
                    return output;
                };
                atob = function(input) {
                    var output = "";
                    var chr1, chr2, chr3;
                    var enc1, enc2, enc3, enc4;
                    var i = 0;
                    if (input.match(base64reg)) {
                        throw new Error("String contains invalid base64 characters");
                    }
                    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                    do {
                        enc1 = key.indexOf(input.charAt(i++));
                        enc2 = key.indexOf(input.charAt(i++));
                        enc3 = key.indexOf(input.charAt(i++));
                        enc4 = key.indexOf(input.charAt(i++));
                        chr1 = enc1 << 2 | enc2 >> 4;
                        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                        chr3 = (enc3 & 3) << 6 | enc4;
                        output = output + chr(chr1);
                        if (enc3 != 64) {
                            output = output + chr(chr2);
                        }
                        if (enc4 != 64) {
                            output = output + chr(chr3);
                        }
                        chr1 = chr2 = chr3 = "";
                        enc1 = enc2 = enc3 = enc4 = "";
                    } while (i < input.length);
                    return output;
                };
            }
            extend(string, true, false, {
                repeat: function(num) {
                    num = checkRepeatRange(num);
                    return repeatString(this, num);
                }
            });
            extend(string, true, function(reg) {
                return isRegExp(reg) || arguments.length > 2;
            }, {
                startsWith: function(reg) {
                    var args = arguments, pos = args[1], c = args[2], str = this, source;
                    if (pos) str = str.slice(pos);
                    if (isUndefined(c)) c = true;
                    source = isRegExp(reg) ? reg.source.replace("^", "") : escapeRegExp(reg);
                    return regexp("^" + source, c ? "" : "i").test(str);
                },
                endsWith: function(reg) {
                    var args = arguments, pos = args[1], c = args[2], str = this, source;
                    if (isDefined(pos)) str = str.slice(0, pos);
                    if (isUndefined(c)) c = true;
                    source = isRegExp(reg) ? reg.source.replace("$", "") : escapeRegExp(reg);
                    return regexp(source + "$", c ? "" : "i").test(str);
                }
            });
            extend(string, true, true, {
                escapeRegExp: function() {
                    return escapeRegExp(this);
                },
                escapeURL: function(param) {
                    return param ? encodeURIComponent(this) : encodeURI(this);
                },
                unescapeURL: function(param) {
                    return param ? decodeURI(this) : decodeURIComponent(this);
                },
                escapeHTML: function() {
                    return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2f;");
                },
                unescapeHTML: function() {
                    return this.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&#x2f;/g, "/").replace(/&amp;/g, "&");
                },
                encodeBase64: function() {
                    return btoa(unescape(encodeURIComponent(this)));
                },
                decodeBase64: function() {
                    return decodeURIComponent(escape(atob(this)));
                },
                each: function(search, fn) {
                    var match, i, len;
                    if (isFunction(search)) {
                        fn = search;
                        search = /[\s\S]/g;
                    } else if (!search) {
                        search = /[\s\S]/g;
                    } else if (isString(search)) {
                        search = regexp(escapeRegExp(search), "gi");
                    } else if (isRegExp(search)) {
                        search = regexp(search.source, getRegExpFlags(search, "g"));
                    }
                    match = this.match(search) || [];
                    if (fn) {
                        for (i = 0, len = match.length; i < len; i++) {
                            match[i] = fn.call(this, match[i], i, match) || match[i];
                        }
                    }
                    return match;
                },
                shift: function(n) {
                    var result = "";
                    n = n || 0;
                    this.codes(function(c) {
                        result += chr(c + n);
                    });
                    return result;
                },
                codes: function(fn) {
                    var codes = [], i, len;
                    for (i = 0, len = this.length; i < len; i++) {
                        var code = this.charCodeAt(i);
                        codes.push(code);
                        if (fn) fn.call(this, code, i);
                    }
                    return codes;
                },
                chars: function(fn) {
                    return this.each(fn);
                },
                words: function(fn) {
                    return this.trim().each(/\S+/g, fn);
                },
                lines: function(fn) {
                    return this.trim().each(/^.*$/gm, fn);
                },
                paragraphs: function(fn) {
                    var paragraphs = this.trim().split(/[\r\n]{2,}/);
                    paragraphs = paragraphs.map(function(p) {
                        if (fn) var s = fn.call(p);
                        return s ? s : p;
                    });
                    return paragraphs;
                },
                isBlank: function() {
                    return this.trim().length === 0;
                },
                has: function(find) {
                    return this.search(isRegExp(find) ? find : escapeRegExp(find)) !== -1;
                },
                add: function(str, index) {
                    index = isUndefined(index) ? this.length : index;
                    return this.slice(0, index) + str + this.slice(index);
                },
                remove: function(f) {
                    return this.replace(f, "");
                },
                reverse: function() {
                    return this.split("").reverse().join("");
                },
                compact: function() {
                    return this.trim().replace(/([\r\n\s　])+/g, function(match, whitespace) {
                        return whitespace === "　" ? whitespace : " ";
                    });
                },
                at: function() {
                    return getEntriesForIndexes(this, arguments, true);
                },
                from: function(from) {
                    return this.slice(numberOrIndex(this, from, true));
                },
                to: function(to) {
                    if (isUndefined(to)) to = this.length;
                    return this.slice(0, numberOrIndex(this, to));
                },
                dasherize: function() {
                    return this.underscore().replace(/_/g, "-");
                },
                underscore: function() {
                    return this.replace(/[-\s]+/g, "_").replace(string.Inflector && string.Inflector.acronymRegExp, function(acronym, index) {
                        return (index > 0 ? "_" : "") + acronym.toLowerCase();
                    }).replace(/([A-Z\d]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").toLowerCase();
                },
                camelize: function(first) {
                    return this.underscore().replace(/(^|_)([^_]+)/g, function(match, pre, word, index) {
                        var acronym = getAcronym(word), capitalize = first !== false || index > 0;
                        if (acronym) return capitalize ? acronym : acronym.toLowerCase();
                        return capitalize ? word.capitalize() : word;
                    });
                },
                spacify: function() {
                    return this.underscore().replace(/_/g, " ");
                },
                stripTags: function() {
                    var str = this, args = arguments.length > 0 ? arguments : [ "" ];
                    flattenedArgs(args, function(tag) {
                        str = str.replace(regexp("</?" + escapeRegExp(tag) + "[^<>]*>", "gi"), "");
                    });
                    return str;
                },
                removeTags: function() {
                    var str = this, args = arguments.length > 0 ? arguments : [ "\\S+" ];
                    flattenedArgs(args, function(t) {
                        var reg = regexp("<(" + t + ")[^<>]*(?:\\/>|>.*?<\\/\\1>)", "gi");
                        str = str.replace(reg, "");
                    });
                    return str;
                },
                truncate: function(length, from, ellipsis) {
                    return truncateString(this, length, from, ellipsis);
                },
                truncateOnWord: function(length, from, ellipsis) {
                    return truncateString(this, length, from, ellipsis, true);
                },
                pad: function(num, padding) {
                    var half, front, back;
                    num = checkRepeatRange(num);
                    half = max(0, num - this.length) / 2;
                    front = floor(half);
                    back = ceil(half);
                    return padString(front, padding) + this + padString(back, padding);
                },
                padLeft: function(num, padding) {
                    num = checkRepeatRange(num);
                    return padString(max(0, num - this.length), padding) + this;
                },
                padRight: function(num, padding) {
                    num = checkRepeatRange(num);
                    return this + padString(max(0, num - this.length), padding);
                },
                first: function(num) {
                    if (isUndefined(num)) num = 1;
                    return this.substr(0, num);
                },
                last: function(num) {
                    if (isUndefined(num)) num = 1;
                    var start = this.length - num < 0 ? 0 : this.length - num;
                    return this.substr(start);
                },
                toNumber: function(base) {
                    return stringToNumber(this, base);
                },
                capitalize: function(all) {
                    var lastResponded;
                    return this.toLowerCase().replace(all ? /[^']/g : /^\S/, function(lower) {
                        var upper = lower.toUpperCase(), result;
                        result = lastResponded ? lower : upper;
                        lastResponded = upper !== lower;
                        return result;
                    });
                },
                assign: function() {
                    var assign = {};
                    flattenedArgs(arguments, function(a, i) {
                        if (isObjectType(a)) {
                            simpleMerge(assign, a);
                        } else {
                            assign[i + 1] = a;
                        }
                    });
                    return this.replace(/\{([^{]+?)\}/g, function(m, key) {
                        return hasOwnProperty(assign, key) ? assign[key] : m;
                    });
                }
            });
            extend(string, true, true, {
                insert: string.prototype.add
            });
            buildBase64("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
            var plurals = [], singulars = [], uncountables = [], humans = [], acronyms = {}, Downcased, Inflector;
            function removeFromArray(arr, find) {
                var index = arr.indexOf(find);
                if (index > -1) {
                    arr.splice(index, 1);
                }
            }
            function removeFromUncountablesAndAddTo(arr, rule, replacement) {
                if (isString(rule)) {
                    removeFromArray(uncountables, rule);
                }
                removeFromArray(uncountables, replacement);
                arr.unshift({
                    rule: rule,
                    replacement: replacement
                });
            }
            function paramMatchesType(param, type) {
                return param == type || param == "all" || !param;
            }
            function isUncountable(word) {
                return uncountables.some(function(uncountable) {
                    return new regexp("\\b" + uncountable + "$", "i").test(word);
                });
            }
            function inflect(word, pluralize) {
                word = isString(word) ? word.toString() : "";
                if (word.isBlank() || isUncountable(word)) {
                    return word;
                } else {
                    return runReplacements(word, pluralize ? plurals : singulars);
                }
            }
            function runReplacements(word, table) {
                iterateOverObject(table, function(i, inflection) {
                    if (word.match(inflection.rule)) {
                        word = word.replace(inflection.rule, inflection.replacement);
                        return false;
                    }
                });
                return word;
            }
            function capitalize(word) {
                return word.replace(/^\W*[a-z]/, function(w) {
                    return w.toUpperCase();
                });
            }
            Inflector = {
                acronym: function(word) {
                    acronyms[word.toLowerCase()] = word;
                    var all = object.keys(acronyms).map(function(key) {
                        return acronyms[key];
                    });
                    Inflector.acronymRegExp = regexp(all.join("|"), "g");
                },
                plural: function(rule, replacement) {
                    removeFromUncountablesAndAddTo(plurals, rule, replacement);
                },
                singular: function(rule, replacement) {
                    removeFromUncountablesAndAddTo(singulars, rule, replacement);
                },
                irregular: function(singular, plural) {
                    var singularFirst = singular.first(), singularRest = singular.from(1), pluralFirst = plural.first(), pluralRest = plural.from(1), pluralFirstUpper = pluralFirst.toUpperCase(), pluralFirstLower = pluralFirst.toLowerCase(), singularFirstUpper = singularFirst.toUpperCase(), singularFirstLower = singularFirst.toLowerCase();
                    removeFromArray(uncountables, singular);
                    removeFromArray(uncountables, plural);
                    if (singularFirstUpper == pluralFirstUpper) {
                        Inflector.plural(new regexp("({1}){2}$".assign(singularFirst, singularRest), "i"), "$1" + pluralRest);
                        Inflector.plural(new regexp("({1}){2}$".assign(pluralFirst, pluralRest), "i"), "$1" + pluralRest);
                        Inflector.singular(new regexp("({1}){2}$".assign(pluralFirst, pluralRest), "i"), "$1" + singularRest);
                    } else {
                        Inflector.plural(new regexp("{1}{2}$".assign(singularFirstUpper, singularRest)), pluralFirstUpper + pluralRest);
                        Inflector.plural(new regexp("{1}{2}$".assign(singularFirstLower, singularRest)), pluralFirstLower + pluralRest);
                        Inflector.plural(new regexp("{1}{2}$".assign(pluralFirstUpper, pluralRest)), pluralFirstUpper + pluralRest);
                        Inflector.plural(new regexp("{1}{2}$".assign(pluralFirstLower, pluralRest)), pluralFirstLower + pluralRest);
                        Inflector.singular(new regexp("{1}{2}$".assign(pluralFirstUpper, pluralRest)), singularFirstUpper + singularRest);
                        Inflector.singular(new regexp("{1}{2}$".assign(pluralFirstLower, pluralRest)), singularFirstLower + singularRest);
                    }
                },
                uncountable: function(first) {
                    var add = array.isArray(first) ? first : multiArgs(arguments);
                    uncountables = uncountables.concat(add);
                },
                human: function(rule, replacement) {
                    humans.unshift({
                        rule: rule,
                        replacement: replacement
                    });
                },
                clear: function(type) {
                    if (paramMatchesType(type, "singulars")) singulars = [];
                    if (paramMatchesType(type, "plurals")) plurals = [];
                    if (paramMatchesType(type, "uncountables")) uncountables = [];
                    if (paramMatchesType(type, "humans")) humans = [];
                    if (paramMatchesType(type, "acronyms")) acronyms = {};
                }
            };
            Downcased = [ "and", "or", "nor", "a", "an", "the", "so", "but", "to", "of", "at", "by", "from", "into", "on", "onto", "off", "out", "in", "over", "with", "for" ];
            Inflector.plural(/$/, "s");
            Inflector.plural(/s$/gi, "s");
            Inflector.plural(/(ax|test)is$/gi, "$1es");
            Inflector.plural(/(octop|vir|fung|foc|radi|alumn)(i|us)$/gi, "$1i");
            Inflector.plural(/(census|alias|status)$/gi, "$1es");
            Inflector.plural(/(bu)s$/gi, "$1ses");
            Inflector.plural(/(buffal|tomat)o$/gi, "$1oes");
            Inflector.plural(/([ti])um$/gi, "$1a");
            Inflector.plural(/([ti])a$/gi, "$1a");
            Inflector.plural(/sis$/gi, "ses");
            Inflector.plural(/f+e?$/gi, "ves");
            Inflector.plural(/(cuff|roof)$/gi, "$1s");
            Inflector.plural(/([ht]ive)$/gi, "$1s");
            Inflector.plural(/([^aeiouy]o)$/gi, "$1es");
            Inflector.plural(/([^aeiouy]|qu)y$/gi, "$1ies");
            Inflector.plural(/(x|ch|ss|sh)$/gi, "$1es");
            Inflector.plural(/(matr|vert|ind)(?:ix|ex)$/gi, "$1ices");
            Inflector.plural(/([ml])ouse$/gi, "$1ice");
            Inflector.plural(/([ml])ice$/gi, "$1ice");
            Inflector.plural(/^(ox)$/gi, "$1en");
            Inflector.plural(/^(oxen)$/gi, "$1");
            Inflector.plural(/(quiz)$/gi, "$1zes");
            Inflector.plural(/(phot|cant|hom|zer|pian|portic|pr|quart|kimon)o$/gi, "$1os");
            Inflector.plural(/(craft)$/gi, "$1");
            Inflector.plural(/([ft])[eo]{2}(th?)$/gi, "$1ee$2");
            Inflector.singular(/s$/gi, "");
            Inflector.singular(/([pst][aiu]s)$/gi, "$1");
            Inflector.singular(/([aeiouy])ss$/gi, "$1ss");
            Inflector.singular(/(n)ews$/gi, "$1ews");
            Inflector.singular(/([ti])a$/gi, "$1um");
            Inflector.singular(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/gi, "$1$2sis");
            Inflector.singular(/(^analy)ses$/gi, "$1sis");
            Inflector.singular(/(i)(f|ves)$/i, "$1fe");
            Inflector.singular(/([aeolr]f?)(f|ves)$/i, "$1f");
            Inflector.singular(/([ht]ive)s$/gi, "$1");
            Inflector.singular(/([^aeiouy]|qu)ies$/gi, "$1y");
            Inflector.singular(/(s)eries$/gi, "$1eries");
            Inflector.singular(/(m)ovies$/gi, "$1ovie");
            Inflector.singular(/(x|ch|ss|sh)es$/gi, "$1");
            Inflector.singular(/([ml])(ous|ic)e$/gi, "$1ouse");
            Inflector.singular(/(bus)(es)?$/gi, "$1");
            Inflector.singular(/(o)es$/gi, "$1");
            Inflector.singular(/(shoe)s?$/gi, "$1");
            Inflector.singular(/(cris|ax|test)[ie]s$/gi, "$1is");
            Inflector.singular(/(octop|vir|fung|foc|radi|alumn)(i|us)$/gi, "$1us");
            Inflector.singular(/(census|alias|status)(es)?$/gi, "$1");
            Inflector.singular(/^(ox)(en)?/gi, "$1");
            Inflector.singular(/(vert|ind)(ex|ices)$/gi, "$1ex");
            Inflector.singular(/(matr)(ix|ices)$/gi, "$1ix");
            Inflector.singular(/(quiz)(zes)?$/gi, "$1");
            Inflector.singular(/(database)s?$/gi, "$1");
            Inflector.singular(/ee(th?)$/gi, "oo$1");
            Inflector.irregular("person", "people");
            Inflector.irregular("man", "men");
            Inflector.irregular("child", "children");
            Inflector.irregular("sex", "sexes");
            Inflector.irregular("move", "moves");
            Inflector.irregular("save", "saves");
            Inflector.irregular("cow", "kine");
            Inflector.irregular("goose", "geese");
            Inflector.irregular("zombie", "zombies");
            Inflector.uncountable("equipment,information,rice,money,species,series,fish,sheep,jeans".split(","));
            extend(string, true, true, {
                pluralize: function() {
                    return inflect(this, true);
                },
                singularize: function() {
                    return inflect(this, false);
                },
                humanize: function() {
                    var str = runReplacements(this, humans), acronym;
                    str = str.replace(/_id$/g, "");
                    str = str.replace(/(_)?([a-z\d]*)/gi, function(match, _, word) {
                        acronym = hasOwnProperty(acronyms, word) ? acronyms[word] : null;
                        return (_ ? " " : "") + (acronym || word.toLowerCase());
                    });
                    return capitalize(str);
                },
                titleize: function() {
                    var fullStopPunctuation = /[.:;!]$/, hasPunctuation, lastHadPunctuation, isFirstOrLast;
                    return this.spacify().humanize().words(function(word, index, words) {
                        hasPunctuation = fullStopPunctuation.test(word);
                        isFirstOrLast = index == 0 || index == words.length - 1 || hasPunctuation || lastHadPunctuation;
                        lastHadPunctuation = hasPunctuation;
                        if (isFirstOrLast || Downcased.indexOf(word) === -1) {
                            return capitalize(word);
                        } else {
                            return word;
                        }
                    }).join(" ");
                },
                parameterize: function(separator) {
                    var str = this;
                    if (separator === undefined) separator = "-";
                    if (str.normalize) {
                        str = str.normalize();
                    }
                    str = str.replace(/[^a-z0-9\-_]+/gi, separator);
                    if (separator) {
                        str = str.replace(new regexp("^{sep}+|{sep}+$|({sep}){sep}+".assign({
                            sep: escapeRegExp(separator)
                        }), "g"), "$1");
                    }
                    return encodeURI(str.toLowerCase());
                }
            });
            string.Inflector = Inflector;
            string.Inflector.acronyms = acronyms;
            var unicodeScripts = [ {
                names: [ "Arabic" ],
                source: "؀-ۿ"
            }, {
                names: [ "Cyrillic" ],
                source: "Ѐ-ӿ"
            }, {
                names: [ "Devanagari" ],
                source: "ऀ-ॿ"
            }, {
                names: [ "Greek" ],
                source: "Ͱ-Ͽ"
            }, {
                names: [ "Hangul" ],
                source: "가-힯ᄀ-ᇿ"
            }, {
                names: [ "Han", "Kanji" ],
                source: "一-鿿豈-﫿"
            }, {
                names: [ "Hebrew" ],
                source: "֐-׿"
            }, {
                names: [ "Hiragana" ],
                source: "぀-ゟ・-ー"
            }, {
                names: [ "Kana" ],
                source: "぀-ヿ｡-ﾟ"
            }, {
                names: [ "Katakana" ],
                source: "゠-ヿ｡-ﾟ"
            }, {
                names: [ "Latin" ],
                source: "--ÿĀ-ſƀ-ɏ"
            }, {
                names: [ "Thai" ],
                source: "฀-๿"
            } ];
            function buildUnicodeScripts() {
                unicodeScripts.forEach(function(s) {
                    var is = regexp("^[" + s.source + "\\s]+$");
                    var has = regexp("[" + s.source + "]");
                    s.names.forEach(function(name) {
                        defineProperty(string.prototype, "is" + name, function() {
                            return is.test(this.trim());
                        });
                        defineProperty(string.prototype, "has" + name, function() {
                            return has.test(this);
                        });
                    });
                });
            }
            var HALF_WIDTH_TO_FULL_WIDTH_TRAVERSAL = 65248;
            var widthConversionRanges = [ {
                type: "a",
                start: 65,
                end: 90
            }, {
                type: "a",
                start: 97,
                end: 122
            }, {
                type: "n",
                start: 48,
                end: 57
            }, {
                type: "p",
                start: 33,
                end: 47
            }, {
                type: "p",
                start: 58,
                end: 64
            }, {
                type: "p",
                start: 91,
                end: 96
            }, {
                type: "p",
                start: 123,
                end: 126
            } ];
            var WidthConversionTable;
            var allHankaku = /[\u0020-\u00A5]|[\uFF61-\uFF9F][ﾞﾟ]?/g;
            var allZenkaku = /[\u3000-\u301C]|[\u301A-\u30FC]|[\uFF01-\uFF60]|[\uFFE0-\uFFE6]/g;
            var hankakuPunctuation = "｡､｢｣¥¢£";
            var zenkakuPunctuation = "。、「」￥￠￡";
            var voicedKatakana = /[カキクケコサシスセソタチツテトハヒフヘホ]/;
            var semiVoicedKatakana = /[ハヒフヘホヲ]/;
            var hankakuKatakana = "ｱｲｳｴｵｧｨｩｪｫｶｷｸｹｺｻｼｽｾｿﾀﾁﾂｯﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔｬﾕｭﾖｮﾗﾘﾙﾚﾛﾜｦﾝｰ･";
            var zenkakuKatakana = "アイウエオァィゥェォカキクケコサシスセソタチツッテトナニヌネノハヒフヘホマミムメモヤャユュヨョラリルレロワヲンー・";
            function convertCharacterWidth(str, args, reg, type) {
                if (!WidthConversionTable) {
                    buildWidthConversionTables();
                }
                var mode = multiArgs(args).join(""), table = WidthConversionTable[type];
                mode = mode.replace(/all/, "").replace(/(\w)lphabet|umbers?|atakana|paces?|unctuation/g, "$1");
                return str.replace(reg, function(c) {
                    if (table[c] && (!mode || mode.has(table[c].type))) {
                        return table[c].to;
                    } else {
                        return c;
                    }
                });
            }
            function buildWidthConversionTables() {
                var hankaku;
                WidthConversionTable = {
                    zenkaku: {},
                    hankaku: {}
                };
                widthConversionRanges.forEach(function(r) {
                    simpleRepeat(r.end - r.start + 1, function(n) {
                        n += r.start;
                        setWidthConversion(r.type, chr(n), chr(n + HALF_WIDTH_TO_FULL_WIDTH_TRAVERSAL));
                    });
                });
                zenkakuKatakana.each(function(c, i) {
                    hankaku = hankakuKatakana.charAt(i);
                    setWidthConversion("k", hankaku, c);
                    if (c.match(voicedKatakana)) {
                        setWidthConversion("k", hankaku + "ﾞ", c.shift(1));
                    }
                    if (c.match(semiVoicedKatakana)) {
                        setWidthConversion("k", hankaku + "ﾟ", c.shift(2));
                    }
                });
                zenkakuPunctuation.each(function(c, i) {
                    setWidthConversion("p", hankakuPunctuation.charAt(i), c);
                });
                setWidthConversion("k", "ｳﾞ", "ヴ");
                setWidthConversion("k", "ｦﾞ", "ヺ");
                setWidthConversion("s", " ", "　");
            }
            function setWidthConversion(type, half, full) {
                WidthConversionTable["zenkaku"][half] = {
                    type: type,
                    to: full
                };
                WidthConversionTable["hankaku"][full] = {
                    type: type,
                    to: half
                };
            }
            extend(string, true, true, {
                hankaku: function() {
                    return convertCharacterWidth(this, arguments, allZenkaku, "hankaku");
                },
                zenkaku: function() {
                    return convertCharacterWidth(this, arguments, allHankaku, "zenkaku");
                },
                hiragana: function(all) {
                    var str = this;
                    if (all !== false) {
                        str = str.zenkaku("k");
                    }
                    return str.replace(/[\u30A1-\u30F6]/g, function(c) {
                        return c.shift(-96);
                    });
                },
                katakana: function() {
                    return this.replace(/[\u3041-\u3096]/g, function(c) {
                        return c.shift(96);
                    });
                }
            });
            buildUnicodeScripts();
            Date.addLocale("da", {
                plural: true,
                months: "januar,februar,marts,april,maj,juni,juli,august,september,oktober,november,december",
                weekdays: "søndag|sondag,mandag,tirsdag,onsdag,torsdag,fredag,lørdag|lordag",
                units: "millisekund:|er,sekund:|er,minut:|ter,tim:e|er,dag:|e,ug:e|er|en,måned:|er|en+maaned:|er|en,år:||et+aar:||et",
                numbers: "en|et,to,tre,fire,fem,seks,syv,otte,ni,ti",
                tokens: "den,for",
                articles: "den",
                "short": "d. {d}. {month} {yyyy}",
                "long": "den {d}. {month} {yyyy} {H}:{mm}",
                full: "{Weekday} den {d}. {month} {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "forgårs|i forgårs|forgaars|i forgaars",
                    value: -2
                }, {
                    name: "day",
                    src: "i går|igår|i gaar|igaar",
                    value: -1
                }, {
                    name: "day",
                    src: "i dag|idag",
                    value: 0
                }, {
                    name: "day",
                    src: "i morgen|imorgen",
                    value: 1
                }, {
                    name: "day",
                    src: "over morgon|overmorgen|i over morgen|i overmorgen|iovermorgen",
                    value: 2
                }, {
                    name: "sign",
                    src: "siden",
                    value: -1
                }, {
                    name: "sign",
                    src: "om",
                    value: 1
                }, {
                    name: "shift",
                    src: "i sidste|sidste",
                    value: -1
                }, {
                    name: "shift",
                    src: "denne",
                    value: 0
                }, {
                    name: "shift",
                    src: "næste|naeste",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{1?} {num} {unit} {sign}", "{shift} {unit=5-7}" ],
                timeParse: [ "{0?} {weekday?} {date?} {month} {year}", "{date} {month}", "{shift} {weekday}" ]
            });
            Date.addLocale("de", {
                plural: true,
                capitalizeUnit: true,
                months: "Januar,Februar,März|Marz,April,Mai,Juni,Juli,August,September,Oktober,November,Dezember",
                weekdays: "Sonntag,Montag,Dienstag,Mittwoch,Donnerstag,Freitag,Samstag",
                units: "Millisekunde:|n,Sekunde:|n,Minute:|n,Stunde:|n,Tag:|en,Woche:|n,Monat:|en,Jahr:|en",
                numbers: "ein:|e|er|en|em,zwei,drei,vier,fuenf,sechs,sieben,acht,neun,zehn",
                tokens: "der",
                "short": "{d}. {Month} {yyyy}",
                "long": "{d}. {Month} {yyyy} {H}:{mm}",
                full: "{Weekday} {d}. {Month} {yyyy} {H}:{mm}:{ss}",
                past: "{sign} {num} {unit}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                timeMarker: "um",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "vorgestern",
                    value: -2
                }, {
                    name: "day",
                    src: "gestern",
                    value: -1
                }, {
                    name: "day",
                    src: "heute",
                    value: 0
                }, {
                    name: "day",
                    src: "morgen",
                    value: 1
                }, {
                    name: "day",
                    src: "übermorgen|ubermorgen|uebermorgen",
                    value: 2
                }, {
                    name: "sign",
                    src: "vor:|her",
                    value: -1
                }, {
                    name: "sign",
                    src: "in",
                    value: 1
                }, {
                    name: "shift",
                    src: "letzte:|r|n|s",
                    value: -1
                }, {
                    name: "shift",
                    src: "nächste:|r|n|s+nachste:|r|n|s+naechste:|r|n|s+kommende:n|r",
                    value: 1
                } ],
                dateParse: [ "{sign} {num} {unit}", "{num} {unit} {sign}", "{shift} {unit=5-7}" ],
                timeParse: [ "{weekday?} {date?} {month} {year?}", "{shift} {weekday}" ]
            });
            Date.addLocale("es", {
                plural: true,
                months: "enero,febrero,marzo,abril,mayo,junio,julio,agosto,septiembre,octubre,noviembre,diciembre",
                weekdays: "domingo,lunes,martes,miércoles|miercoles,jueves,viernes,sábado|sabado",
                units: "milisegundo:|s,segundo:|s,minuto:|s,hora:|s,día|días|dia|dias,semana:|s,mes:|es,año|años|ano|anos",
                numbers: "uno,dos,tres,cuatro,cinco,seis,siete,ocho,nueve,diez",
                tokens: "el,la,de",
                "short": "{d} {month} {yyyy}",
                "long": "{d} {month} {yyyy} {H}:{mm}",
                full: "{Weekday} {d} {month} {yyyy} {H}:{mm}:{ss}",
                past: "{sign} {num} {unit}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                timeMarker: "a las",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "anteayer",
                    value: -2
                }, {
                    name: "day",
                    src: "ayer",
                    value: -1
                }, {
                    name: "day",
                    src: "hoy",
                    value: 0
                }, {
                    name: "day",
                    src: "mañana|manana",
                    value: 1
                }, {
                    name: "sign",
                    src: "hace",
                    value: -1
                }, {
                    name: "sign",
                    src: "dentro de",
                    value: 1
                }, {
                    name: "shift",
                    src: "pasad:o|a",
                    value: -1
                }, {
                    name: "shift",
                    src: "próximo|próxima|proximo|proxima",
                    value: 1
                } ],
                dateParse: [ "{sign} {num} {unit}", "{num} {unit} {sign}", "{0?}{1?} {unit=5-7} {shift}", "{0?}{1?} {shift} {unit=5-7}" ],
                timeParse: [ "{shift} {weekday}", "{weekday} {shift}", "{date?} {2?} {month} {2?} {year?}" ]
            });
            Date.addLocale("fi", {
                plural: true,
                timeMarker: "kello",
                ampm: ",",
                months: "tammikuu,helmikuu,maaliskuu,huhtikuu,toukokuu,kesäkuu,heinäkuu,elokuu,syyskuu,lokakuu,marraskuu,joulukuu",
                weekdays: "sunnuntai,maanantai,tiistai,keskiviikko,torstai,perjantai,lauantai",
                units: "millisekun:ti|tia|teja|tina|nin,sekun:ti|tia|teja|tina|nin,minuut:ti|tia|teja|tina|in,tun:ti|tia|teja|tina|nin,päiv:ä|ää|iä|änä|än,viik:ko|koa|koja|on|kona,kuukau:si|sia|tta|den|tena,vuo:si|sia|tta|den|tena",
                numbers: "yksi|ensimmäinen,kaksi|toinen,kolm:e|as,neljä:s,vii:si|des,kuu:si|des,seitsemä:n|s,kahdeksa:n|s,yhdeksä:n|s,kymmene:n|s",
                articles: "",
                optionals: "",
                "short": "{d}. {month}ta {yyyy}",
                "long": "{d}. {month}ta {yyyy} kello {H}.{mm}",
                full: "{Weekday}na {d}. {month}ta {yyyy} kello {H}.{mm}",
                relative: function(num, unit, ms, format) {
                    var units = this["units"];
                    function numberWithUnit(mult) {
                        return (num === 1 ? "" : num + " ") + units[8 * mult + unit];
                    }
                    switch (format) {
                      case "duration":
                        return numberWithUnit(0);

                      case "past":
                        return numberWithUnit(num > 1 ? 1 : 0) + " sitten";

                      case "future":
                        return numberWithUnit(4) + " päästä";
                    }
                },
                modifiers: [ {
                    name: "day",
                    src: "toissa päivänä|toissa päiväistä",
                    value: -2
                }, {
                    name: "day",
                    src: "eilen|eilistä",
                    value: -1
                }, {
                    name: "day",
                    src: "tänään",
                    value: 0
                }, {
                    name: "day",
                    src: "huomenna|huomista",
                    value: 1
                }, {
                    name: "day",
                    src: "ylihuomenna|ylihuomista",
                    value: 2
                }, {
                    name: "sign",
                    src: "sitten|aiemmin",
                    value: -1
                }, {
                    name: "sign",
                    src: "päästä|kuluttua|myöhemmin",
                    value: 1
                }, {
                    name: "edge",
                    src: "viimeinen|viimeisenä",
                    value: -2
                }, {
                    name: "edge",
                    src: "lopussa",
                    value: -1
                }, {
                    name: "edge",
                    src: "ensimmäinen|ensimmäisenä",
                    value: 1
                }, {
                    name: "shift",
                    src: "edellinen|edellisenä|edeltävä|edeltävänä|viime|toissa",
                    value: -1
                }, {
                    name: "shift",
                    src: "tänä|tämän",
                    value: 0
                }, {
                    name: "shift",
                    src: "seuraava|seuraavana|tuleva|tulevana|ensi",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{num} {unit=4-5} {sign} {day}", "{month} {year}", "{shift} {unit=5-7}" ],
                timeParse: [ "{0} {num}{1} {day} of {month} {year?}", "{weekday?} {month} {date}{1} {year?}", "{date} {month} {year}", "{shift} {weekday}", "{shift} week {weekday}", "{weekday} {2} {shift} week", "{0} {date}{1} of {month}", "{0}{month?} {date?}{1} of {shift} {unit=6-7}" ]
            });
            Date.addLocale("fr", {
                plural: true,
                months: "janvier,février|fevrier,mars,avril,mai,juin,juillet,août,septembre,octobre,novembre,décembre|decembre",
                weekdays: "dimanche,lundi,mardi,mercredi,jeudi,vendredi,samedi",
                units: "milliseconde:|s,seconde:|s,minute:|s,heure:|s,jour:|s,semaine:|s,mois,an:|s|née|nee",
                numbers: "un:|e,deux,trois,quatre,cinq,six,sept,huit,neuf,dix",
                tokens: "l'|la|le",
                "short": "{d} {month} {yyyy}",
                "long": "{d} {month} {yyyy} {H}:{mm}",
                full: "{Weekday} {d} {month} {yyyy} {H}:{mm}:{ss}",
                past: "{sign} {num} {unit}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                timeMarker: "à",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "hier",
                    value: -1
                }, {
                    name: "day",
                    src: "aujourd'hui",
                    value: 0
                }, {
                    name: "day",
                    src: "demain",
                    value: 1
                }, {
                    name: "sign",
                    src: "il y a",
                    value: -1
                }, {
                    name: "sign",
                    src: "dans|d'ici",
                    value: 1
                }, {
                    name: "shift",
                    src: "derni:èr|er|ère|ere",
                    value: -1
                }, {
                    name: "shift",
                    src: "prochain:|e",
                    value: 1
                } ],
                dateParse: [ "{sign} {num} {unit}", "{sign} {num} {unit}", "{0?} {unit=5-7} {shift}" ],
                timeParse: [ "{weekday?} {0?} {date?} {month} {year?}", "{0?} {weekday} {shift}" ]
            });
            Date.addLocale("it", {
                plural: true,
                months: "Gennaio,Febbraio,Marzo,Aprile,Maggio,Giugno,Luglio,Agosto,Settembre,Ottobre,Novembre,Dicembre",
                weekdays: "Domenica,Luned:ì|i,Marted:ì|i,Mercoled:ì|i,Gioved:ì|i,Venerd:ì|i,Sabato",
                units: "millisecond:o|i,second:o|i,minut:o|i,or:a|e,giorn:o|i,settiman:a|e,mes:e|i,ann:o|i",
                numbers: "un:|a|o|',due,tre,quattro,cinque,sei,sette,otto,nove,dieci",
                tokens: "l'|la|il",
                "short": "{d} {Month} {yyyy}",
                "long": "{d} {Month} {yyyy} {H}:{mm}",
                full: "{Weekday} {d} {Month} {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{num} {unit} {sign}",
                duration: "{num} {unit}",
                timeMarker: "alle",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "ieri",
                    value: -1
                }, {
                    name: "day",
                    src: "oggi",
                    value: 0
                }, {
                    name: "day",
                    src: "domani",
                    value: 1
                }, {
                    name: "day",
                    src: "dopodomani",
                    value: 2
                }, {
                    name: "sign",
                    src: "fa",
                    value: -1
                }, {
                    name: "sign",
                    src: "da adesso",
                    value: 1
                }, {
                    name: "shift",
                    src: "scors:o|a",
                    value: -1
                }, {
                    name: "shift",
                    src: "prossim:o|a",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{0?} {unit=5-7} {shift}", "{0?} {shift} {unit=5-7}" ],
                timeParse: [ "{weekday?} {date?} {month} {year?}", "{shift} {weekday}" ]
            });
            Date.addLocale("ja", {
                monthSuffix: "月",
                weekdays: "日曜日,月曜日,火曜日,水曜日,木曜日,金曜日,土曜日",
                units: "ミリ秒,秒,分,時間,日,週間|週,ヶ月|ヵ月|月,年",
                "short": "{yyyy}年{M}月{d}日",
                "long": "{yyyy}年{M}月{d}日 {H}時{mm}分",
                full: "{yyyy}年{M}月{d}日 {Weekday} {H}時{mm}分{ss}秒",
                past: "{num}{unit}{sign}",
                future: "{num}{unit}{sign}",
                duration: "{num}{unit}",
                timeSuffixes: "時,分,秒",
                ampm: "午前,午後",
                modifiers: [ {
                    name: "day",
                    src: "一昨日",
                    value: -2
                }, {
                    name: "day",
                    src: "昨日",
                    value: -1
                }, {
                    name: "day",
                    src: "今日",
                    value: 0
                }, {
                    name: "day",
                    src: "明日",
                    value: 1
                }, {
                    name: "day",
                    src: "明後日",
                    value: 2
                }, {
                    name: "sign",
                    src: "前",
                    value: -1
                }, {
                    name: "sign",
                    src: "後",
                    value: 1
                }, {
                    name: "shift",
                    src: "去|先",
                    value: -1
                }, {
                    name: "shift",
                    src: "来",
                    value: 1
                } ],
                dateParse: [ "{num}{unit}{sign}" ],
                timeParse: [ "{shift}{unit=5-7}{weekday?}", "{year}年{month?}月?{date?}日?", "{month}月{date?}日?", "{date}日" ]
            });
            Date.addLocale("ko", {
                digitDate: true,
                monthSuffix: "월",
                weekdays: "일요일,월요일,화요일,수요일,목요일,금요일,토요일",
                units: "밀리초,초,분,시간,일,주,개월|달,년",
                numbers: "일|한,이,삼,사,오,육,칠,팔,구,십",
                "short": "{yyyy}년{M}월{d}일",
                "long": "{yyyy}년{M}월{d}일 {H}시{mm}분",
                full: "{yyyy}년{M}월{d}일 {Weekday} {H}시{mm}분{ss}초",
                past: "{num}{unit} {sign}",
                future: "{num}{unit} {sign}",
                duration: "{num}{unit}",
                timeSuffixes: "시,분,초",
                ampm: "오전,오후",
                modifiers: [ {
                    name: "day",
                    src: "그저께",
                    value: -2
                }, {
                    name: "day",
                    src: "어제",
                    value: -1
                }, {
                    name: "day",
                    src: "오늘",
                    value: 0
                }, {
                    name: "day",
                    src: "내일",
                    value: 1
                }, {
                    name: "day",
                    src: "모레",
                    value: 2
                }, {
                    name: "sign",
                    src: "전",
                    value: -1
                }, {
                    name: "sign",
                    src: "후",
                    value: 1
                }, {
                    name: "shift",
                    src: "지난|작",
                    value: -1
                }, {
                    name: "shift",
                    src: "이번",
                    value: 0
                }, {
                    name: "shift",
                    src: "다음|내",
                    value: 1
                } ],
                dateParse: [ "{num}{unit} {sign}", "{shift?} {unit=5-7}" ],
                timeParse: [ "{shift} {unit=5?} {weekday}", "{year}년{month?}월?{date?}일?", "{month}월{date?}일?", "{date}일" ]
            });
            Date.addLocale("nl", {
                plural: true,
                months: "januari,februari,maart,april,mei,juni,juli,augustus,september,oktober,november,december",
                weekdays: "zondag|zo,maandag|ma,dinsdag|di,woensdag|woe|wo,donderdag|do,vrijdag|vrij|vr,zaterdag|za",
                units: "milliseconde:|n,seconde:|n,minu:ut|ten,uur,dag:|en,we:ek|ken,maand:|en,jaar",
                numbers: "een,twee,drie,vier,vijf,zes,zeven,acht,negen",
                tokens: "",
                "short": "{d} {Month} {yyyy}",
                "long": "{d} {Month} {yyyy} {H}:{mm}",
                full: "{Weekday} {d} {Month} {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{num} {unit} {sign}",
                duration: "{num} {unit}",
                timeMarker: "'s|om",
                modifiers: [ {
                    name: "day",
                    src: "gisteren",
                    value: -1
                }, {
                    name: "day",
                    src: "vandaag",
                    value: 0
                }, {
                    name: "day",
                    src: "morgen",
                    value: 1
                }, {
                    name: "day",
                    src: "overmorgen",
                    value: 2
                }, {
                    name: "sign",
                    src: "geleden",
                    value: -1
                }, {
                    name: "sign",
                    src: "vanaf nu",
                    value: 1
                }, {
                    name: "shift",
                    src: "laatste|vorige|afgelopen",
                    value: -1
                }, {
                    name: "shift",
                    src: "volgend:|e",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{0?} {unit=5-7} {shift}", "{0?} {shift} {unit=5-7}" ],
                timeParse: [ "{weekday?} {date?} {month} {year?}", "{shift} {weekday}" ]
            });
            Date.addLocale("pl", {
                plural: true,
                months: "Styczeń|Stycznia,Luty|Lutego,Marzec|Marca,Kwiecień|Kwietnia,Maj|Maja,Czerwiec|Czerwca,Lipiec|Lipca,Sierpień|Sierpnia,Wrzesień|Września,Październik|Października,Listopad|Listopada,Grudzień|Grudnia",
                weekdays: "Niedziela|Niedzielę,Poniedziałek,Wtorek,Środ:a|ę,Czwartek,Piątek,Sobota|Sobotę",
                units: "milisekund:a|y|,sekund:a|y|,minut:a|y|,godzin:a|y|,dzień|dni,tydzień|tygodnie|tygodni,miesiące|miesiące|miesięcy,rok|lata|lat",
                numbers: "jeden|jedną,dwa|dwie,trzy,cztery,pięć,sześć,siedem,osiem,dziewięć,dziesięć",
                optionals: "w|we,roku",
                "short": "{d} {Month} {yyyy}",
                "long": "{d} {Month} {yyyy} {H}:{mm}",
                full: "{Weekday}, {d} {Month} {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                timeMarker: "o",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "przedwczoraj",
                    value: -2
                }, {
                    name: "day",
                    src: "wczoraj",
                    value: -1
                }, {
                    name: "day",
                    src: "dzisiaj|dziś",
                    value: 0
                }, {
                    name: "day",
                    src: "jutro",
                    value: 1
                }, {
                    name: "day",
                    src: "pojutrze",
                    value: 2
                }, {
                    name: "sign",
                    src: "temu|przed",
                    value: -1
                }, {
                    name: "sign",
                    src: "za",
                    value: 1
                }, {
                    name: "shift",
                    src: "zeszły|zeszła|ostatni|ostatnia",
                    value: -1
                }, {
                    name: "shift",
                    src: "następny|następna|następnego|przyszły|przyszła|przyszłego",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{month} {year}", "{shift} {unit=5-7}", "{0} {shift?} {weekday}" ],
                timeParse: [ "{date} {month} {year?} {1}", "{0} {shift?} {weekday}" ]
            });
            Date.addLocale("pt", {
                plural: true,
                months: "janeiro,fevereiro,março,abril,maio,junho,julho,agosto,setembro,outubro,novembro,dezembro",
                weekdays: "domingo,segunda-feira,terça-feira,quarta-feira,quinta-feira,sexta-feira,sábado|sabado",
                units: "milisegundo:|s,segundo:|s,minuto:|s,hora:|s,dia:|s,semana:|s,mês|mêses|mes|meses,ano:|s",
                numbers: "um,dois,três|tres,quatro,cinco,seis,sete,oito,nove,dez,uma,duas",
                tokens: "a,de",
                "short": "{d} de {month} de {yyyy}",
                "long": "{d} de {month} de {yyyy} {H}:{mm}",
                full: "{Weekday}, {d} de {month} de {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                timeMarker: "às",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "anteontem",
                    value: -2
                }, {
                    name: "day",
                    src: "ontem",
                    value: -1
                }, {
                    name: "day",
                    src: "hoje",
                    value: 0
                }, {
                    name: "day",
                    src: "amanh:ã|a",
                    value: 1
                }, {
                    name: "sign",
                    src: "atrás|atras|há|ha",
                    value: -1
                }, {
                    name: "sign",
                    src: "daqui a",
                    value: 1
                }, {
                    name: "shift",
                    src: "passad:o|a",
                    value: -1
                }, {
                    name: "shift",
                    src: "próximo|próxima|proximo|proxima",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{0?} {unit=5-7} {shift}", "{0?} {shift} {unit=5-7}" ],
                timeParse: [ "{date?} {1?} {month} {1?} {year?}", "{0?} {shift} {weekday}" ]
            });
            Date.addLocale("ru", {
                months: "Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь",
                weekdays: "Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота",
                units: "миллисекунд:а|у|ы|,секунд:а|у|ы|,минут:а|у|ы|,час:||а|ов,день|день|дня|дней,недел:я|ю|и|ь|е,месяц:||а|ев|е,год|год|года|лет|году",
                numbers: "од:ин|ну,дв:а|е,три,четыре,пять,шесть,семь,восемь,девять,десять",
                tokens: "в|на,года",
                "short": "{d} {month} {yyyy} года",
                "long": "{d} {month} {yyyy} года {H}:{mm}",
                full: "{Weekday} {d} {month} {yyyy} года {H}:{mm}:{ss}",
                relative: function(num, unit, ms, format) {
                    var numberWithUnit, last = num.toString().slice(-1), mult;
                    switch (true) {
                      case num >= 11 && num <= 15:
                        mult = 3;
                        break;

                      case last == 1:
                        mult = 1;
                        break;

                      case last >= 2 && last <= 4:
                        mult = 2;
                        break;

                      default:
                        mult = 3;
                    }
                    numberWithUnit = num + " " + this["units"][mult * 8 + unit];
                    switch (format) {
                      case "duration":
                        return numberWithUnit;

                      case "past":
                        return numberWithUnit + " назад";

                      case "future":
                        return "через " + numberWithUnit;
                    }
                },
                timeMarker: "в",
                ampm: " утра, вечера",
                modifiers: [ {
                    name: "day",
                    src: "позавчера",
                    value: -2
                }, {
                    name: "day",
                    src: "вчера",
                    value: -1
                }, {
                    name: "day",
                    src: "сегодня",
                    value: 0
                }, {
                    name: "day",
                    src: "завтра",
                    value: 1
                }, {
                    name: "day",
                    src: "послезавтра",
                    value: 2
                }, {
                    name: "sign",
                    src: "назад",
                    value: -1
                }, {
                    name: "sign",
                    src: "через",
                    value: 1
                }, {
                    name: "shift",
                    src: "прошл:ый|ой|ом",
                    value: -1
                }, {
                    name: "shift",
                    src: "следующ:ий|ей|ем",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{month} {year}", "{0?} {shift} {unit=5-7}" ],
                timeParse: [ "{date} {month} {year?} {1?}", "{0?} {shift} {weekday}" ]
            });
            Date.addLocale("sv", {
                plural: true,
                months: "januari,februari,mars,april,maj,juni,juli,augusti,september,oktober,november,december",
                weekdays: "söndag|sondag,måndag:|en+mandag:|en,tisdag,onsdag,torsdag,fredag,lördag|lordag",
                units: "millisekund:|er,sekund:|er,minut:|er,timm:e|ar,dag:|ar,veck:a|or|an,månad:|er|en+manad:|er|en,år:||et+ar:||et",
                numbers: "en|ett,två|tva,tre,fyra,fem,sex,sju,åtta|atta,nio,tio",
                tokens: "den,för|for",
                articles: "den",
                "short": "den {d} {month} {yyyy}",
                "long": "den {d} {month} {yyyy} {H}:{mm}",
                full: "{Weekday} den {d} {month} {yyyy} {H}:{mm}:{ss}",
                past: "{num} {unit} {sign}",
                future: "{sign} {num} {unit}",
                duration: "{num} {unit}",
                ampm: "am,pm",
                modifiers: [ {
                    name: "day",
                    src: "förrgår|i förrgår|iförrgår|forrgar|i forrgar|iforrgar",
                    value: -2
                }, {
                    name: "day",
                    src: "går|i går|igår|gar|i gar|igar",
                    value: -1
                }, {
                    name: "day",
                    src: "dag|i dag|idag",
                    value: 0
                }, {
                    name: "day",
                    src: "morgon|i morgon|imorgon",
                    value: 1
                }, {
                    name: "day",
                    src: "över morgon|övermorgon|i över morgon|i övermorgon|iövermorgon|over morgon|overmorgon|i over morgon|i overmorgon|iovermorgon",
                    value: 2
                }, {
                    name: "sign",
                    src: "sedan|sen",
                    value: -1
                }, {
                    name: "sign",
                    src: "om",
                    value: 1
                }, {
                    name: "shift",
                    src: "i förra|förra|i forra|forra",
                    value: -1
                }, {
                    name: "shift",
                    src: "denna",
                    value: 0
                }, {
                    name: "shift",
                    src: "nästa|nasta",
                    value: 1
                } ],
                dateParse: [ "{num} {unit} {sign}", "{sign} {num} {unit}", "{1?} {num} {unit} {sign}", "{shift} {unit=5-7}" ],
                timeParse: [ "{0?} {weekday?} {date?} {month} {year}", "{date} {month}", "{shift} {weekday}" ]
            });
            Date.addLocale("zh-CN", {
                variant: true,
                monthSuffix: "月",
                weekdays: "星期日|周日,星期一|周一,星期二|周二,星期三|周三,星期四|周四,星期五|周五,星期六|周六",
                units: "毫秒,秒钟,分钟,小时,天,个星期|周,个月,年",
                tokens: "日|号",
                "short": "{yyyy}年{M}月{d}日",
                "long": "{yyyy}年{M}月{d}日 {tt}{h}:{mm}",
                full: "{yyyy}年{M}月{d}日 {weekday} {tt}{h}:{mm}:{ss}",
                past: "{num}{unit}{sign}",
                future: "{num}{unit}{sign}",
                duration: "{num}{unit}",
                timeSuffixes: "点|时,分钟?,秒",
                ampm: "上午,下午",
                modifiers: [ {
                    name: "day",
                    src: "前天",
                    value: -2
                }, {
                    name: "day",
                    src: "昨天",
                    value: -1
                }, {
                    name: "day",
                    src: "今天",
                    value: 0
                }, {
                    name: "day",
                    src: "明天",
                    value: 1
                }, {
                    name: "day",
                    src: "后天",
                    value: 2
                }, {
                    name: "sign",
                    src: "前",
                    value: -1
                }, {
                    name: "sign",
                    src: "后",
                    value: 1
                }, {
                    name: "shift",
                    src: "上|去",
                    value: -1
                }, {
                    name: "shift",
                    src: "这",
                    value: 0
                }, {
                    name: "shift",
                    src: "下|明",
                    value: 1
                } ],
                dateParse: [ "{num}{unit}{sign}", "{shift}{unit=5-7}" ],
                timeParse: [ "{shift}{weekday}", "{year}年{month?}月?{date?}{0?}", "{month}月{date?}{0?}", "{date}[日号]" ]
            });
            Date.addLocale("zh-TW", {
                monthSuffix: "月",
                weekdays: "星期日|週日,星期一|週一,星期二|週二,星期三|週三,星期四|週四,星期五|週五,星期六|週六",
                units: "毫秒,秒鐘,分鐘,小時,天,個星期|週,個月,年",
                tokens: "日|號",
                "short": "{yyyy}年{M}月{d}日",
                "long": "{yyyy}年{M}月{d}日 {tt}{h}:{mm}",
                full: "{yyyy}年{M}月{d}日 {Weekday} {tt}{h}:{mm}:{ss}",
                past: "{num}{unit}{sign}",
                future: "{num}{unit}{sign}",
                duration: "{num}{unit}",
                timeSuffixes: "點|時,分鐘?,秒",
                ampm: "上午,下午",
                modifiers: [ {
                    name: "day",
                    src: "前天",
                    value: -2
                }, {
                    name: "day",
                    src: "昨天",
                    value: -1
                }, {
                    name: "day",
                    src: "今天",
                    value: 0
                }, {
                    name: "day",
                    src: "明天",
                    value: 1
                }, {
                    name: "day",
                    src: "後天",
                    value: 2
                }, {
                    name: "sign",
                    src: "前",
                    value: -1
                }, {
                    name: "sign",
                    src: "後",
                    value: 1
                }, {
                    name: "shift",
                    src: "上|去",
                    value: -1
                }, {
                    name: "shift",
                    src: "這",
                    value: 0
                }, {
                    name: "shift",
                    src: "下|明",
                    value: 1
                } ],
                dateParse: [ "{num}{unit}{sign}", "{shift}{unit=5-7}" ],
                timeParse: [ "{shift}{weekday}", "{year}年{month?}月?{date?}{0?}", "{month}月{date?}{0?}", "{date}[日號]" ]
            });
        }).call(this);
    });
    require.define("/src/forum-topics/times.ls", function(module, exports, __dirname, __filename) {
        var lang, parseTime, $$, current, postTitles, dates, i$, len$, postTitle, postTimestamp, date, timestamp;
        lang = require("/lib/lang/index.ls", module);
        parseTime = require("/lib/parse-time/index.ls", module);
        $$ = require("/lib/dom/index.ls", module).$$;
        current = Date.now();
        postTitles = $$(".post-title[data-date-string]");
        dates = [];
        for (i$ = 0, len$ = postTitles.length; i$ < len$; ++i$) {
            postTitle = postTitles[i$];
            postTimestamp = parseTime(postTitle.dataset.dateString);
            date = Date.create(current - postTimestamp);
            timestamp = date.getTime();
            dates[timestamp] = date;
            postTitle.dataset.timestamp = timestamp;
        }
        (function() {
            var i$, ref$, len$, postTitle, date, results$ = [];
            for (i$ = 0, len$ = (ref$ = postTitles).length; i$ < len$; ++i$) {
                postTitle = ref$[i$];
                date = dates[postTitle.dataset.timestamp];
                results$.push(postTitle.querySelector(".relative-date").innerHTML = date.relative());
            }
            return results$;
        }).every(10..seconds());
    });
    require.define("/lib/parse-time/index.ls", function(module, exports, __dirname, __filename) {
        var lang, units, res$, i$, ref$, len$, name, split$ = "".split;
        lang = require("/lib/lang/index.ls", module);
        res$ = {};
        for (i$ = 0, len$ = (ref$ = [ "second", "minute", "hour", "day" ]).length; i$ < len$; ++i$) {
            name = ref$[i$];
            res$[name] = 1[name]();
        }
        units = res$;
        module.exports = function(it) {
            var total, i$, ref$, len$, timespan, ref1$, count, unit;
            total = 0;
            for (i$ = 0, len$ = (ref$ = split$.call(it, ", ")).length; i$ < len$; ++i$) {
                timespan = ref$[i$];
                ref1$ = split$.call(timespan, " "), count = ref1$[0], unit = ref1$[1];
                count = +count;
                if (count === lang("few")) {
                    count = 5;
                    unit = lang("second");
                }
                total += count * units[lang(lang.singularize(unit))];
            }
            return total;
        };
    });
    require.define("/src/forum-topics/hide-topic.ls", function(module, exports, __dirname, __filename) {
        var tbodyRegular, ref$, $, $$, el, templateHideTopic, hiddenTopics, i$, len$, split$ = "".split, join$ = [].join;
        tbodyRegular = require("/src/tbody-regular.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, $$ = ref$.$$, el = ref$.el;
        templateHideTopic = require("/src/forum-topics/templates/hide-topic.ne", module);
        hiddenTopics = split$.call(localStorage.getItem("hidden_topics") || "", ";");
        function saveHiddens() {
            localStorage.setItem("hidden_topics", join$.call(hiddenTopics, ";"));
        }
        function hide(it) {
            var that;
            it.parentNode.removeChild(it);
            tbodyRegular.appendChild(it);
            it.className += " hidden";
            if (that = it.querySelector(".last-read")) {
                that.parentNode.removeChild(that);
            }
        }
        for (i$ = 0, len$ = (ref$ = $$(".regular-topic")).length; i$ < len$; ++i$) {
            fn$.call(this, ref$[i$]);
        }
        function in$(x, xs) {
            var i = -1, l = xs.length >>> 0;
            while (++i < l) if (x === xs[i]) return true;
            return false;
        }
        function fn$(tr) {
            var topicId, pagesWrapper, x$;
            topicId = tr.id.slice("postRow".length);
            pagesWrapper = $(".post-pages-cell", tr);
            if (in$(topicId, hiddenTopics)) {
                hide(tr);
            }
            x$ = el(templateHideTopic({
                hidden: in$(topicId, hiddenTopics)
            }));
            x$.onclick = function() {
                if (in$(topicId, hiddenTopics)) {
                    pagesWrapper.removeChild(x$);
                    hiddenTopics.splice(hiddenTopics.indexOf(topicId), 1);
                } else {
                    hide(tr);
                    hiddenTopics.push(topicId);
                }
                return saveHiddens();
            };
            pagesWrapper.insertBefore(x$, pagesWrapper.children[0]);
        }
    });
    require.define("/src/forum-topics/templates/hide-topic.ne", function(module, exports, __dirname, __filename) {
        var join;
        join = function(it) {
            if (it) {
                return it.join("");
            } else {
                return "";
            }
        };
        module.exports = function(locals, extra) {
            return "" + ((locals.hidden ? '<a class="last-read show-topic">✓</a>' : '<a class="last-read hide-topic">X</a>') || "");
        };
    });
    require.define("/src/tbody-regular.ls", function(module, exports, __dirname, __filename) {
        var $;
        $ = require("/lib/dom/index.ls", module).$;
        module.exports = $("tbody.regular-topics");
    });
    require.define("/src/forum-topics/move-redirects.ls", function(module, exports, __dirname, __filename) {
        var tbodyRegular, i$, ref$, len$, status, tr;
        tbodyRegular = require("/src/tbody-regular.ls", module);
        for (i$ = 0, len$ = (ref$ = tbodyRegular.querySelectorAll(".status-text")).length; i$ < len$; ++i$) {
            status = ref$[i$];
            tr = status.parentNode.parentNode.parentNode;
            tr.className += " hidden redirect";
            tbodyRegular.removeChild(tr);
            tbodyRegular.appendChild(tr);
        }
    });
    require.define("/src/forum-layout/hide-mar.ls", function(module, exports, __dirname, __filename) {
        var $;
        $ = require("/lib/dom/index.ls", module).$;
        if (!$("tbody.regular-topics > .unread:not(.hidden)")) {
            require("/src/forum-options.ls", module).removeChild(require("/src/forum-layout/mar.ls", module));
        }
    });
    require.define("/src/forum-layout/mar.ls", function(module, exports, __dirname, __filename) {
        var lang, fetchSiblings, forumOptions, tbodyRegular, node, allRead, buttonMar, x$, split$ = "".split;
        lang = require("/lib/lang/index.ls", module);
        fetchSiblings = require("/lib/fetch-siblings/index.ls", module);
        forumOptions = require("/src/forum-options.ls", module);
        tbodyRegular = require("/src/tbody-regular.ls", module);
        node = require("/lib/dom/index.ls", module).node;
        allRead = false;
        module.exports = buttonMar = node("a", {
            innerHTML: "MAR",
            title: lang.mar,
            onclick: function() {
                var i$, ref$, len$, row, topicId, siblings, x$;
                if (allRead) {
                    return;
                }
                allRead = !allRead;
                for (i$ = 0, len$ = (ref$ = tbodyRegular.children).length; i$ < len$; ++i$) {
                    row = ref$[i$];
                    if (row.classList.contains("read")) {
                        continue;
                    }
                    topicId = row.id.slice("postRow".length);
                    siblings = fetchSiblings(row.children[0]);
                    x$ = localStorage;
                    x$["topic_" + topicId] = split$.call(siblings["last-post-cell"].children[0].href, "#")[1];
                    x$["topic_lp_" + topicId] = siblings["author-cell"].innerHTML.trim();
                    row.classList.add("read");
                }
                forumOptions.removeChild(buttonMar);
            }
        });
        x$ = buttonMar;
        x$.style.cursor = "pointer";
        forumOptions.appendChild(x$);
    });
    require.define("/src/forum-options.ls", function(module, exports, __dirname, __filename) {
        var ref$, $, node, x$, actionsRight, forumOptions;
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, node = ref$.node;
        x$ = actionsRight = $(".forum-actions-top .paging-wrapper");
        x$.insertBefore(forumOptions = node("div", {
            className: "forum-options"
        }), $(".inner-search-wrapper", x$));
        module.exports = forumOptions;
    });
    require.define("/lib/fetch-siblings/index.ls", function(module, exports, __dirname, __filename) {
        module.exports = function() {
            function fetchSiblings(elem, arg$) {
                var ref$, slice, ref1$, indexBy, resultObj$ = {};
                ref$ = arg$ != null ? arg$ : {}, slice = (ref1$ = ref$.slice) != null ? ref1$ : 0, 
                indexBy = (ref1$ = ref$.indexBy) != null ? ref1$ : "className";
                while (elem != null && (elem = elem.nextElementSibling)) {
                    resultObj$[(ref$ = elem[indexBy].slice(slice).split(" "))[ref$.length - 1]] = elem;
                }
                return resultObj$;
            }
            return fetchSiblings;
        }();
    });
    require.define("/src/forum-layout/index.ls", function(module, exports, __dirname, __filename) {
        var mar, moveActions, stickies;
        mar = require("/src/forum-layout/mar.ls", module);
        moveActions = require("/src/forum-layout/move-actions.ls", module);
        stickies = require("/src/forum-layout/stickies.ls", module);
    });
    require.define("/src/forum-layout/stickies.ls", function(module, exports, __dirname, __filename) {
        var lang, forumOptions, ref$, $, node, sticky, buttonSticky, x$;
        lang = require("/lib/lang/index.ls", module);
        forumOptions = require("/src/forum-options.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, node = ref$.node;
        sticky = $("tbody.stickied-topics");
        if ("show" !== localStorage.getItem("show-stickies")) {
            sticky.style.display = "none";
        }
        module.exports = buttonSticky = node("a", {
            innerHTML: "Post-its",
            title: lang.toggleSticky,
            onclick: function() {
                var s;
                (s = sticky.style).display = [ "none", "" ].find(function(it) {
                    return it !== s.display;
                });
                localStorage.setItem("show-stickies", s.display) || "show";
            }
        });
        x$ = buttonSticky;
        x$.style.cursor = "pointer";
        forumOptions.appendChild(x$);
    });
    require.define("/src/forum-layout/move-actions.ls", function(module, exports, __dirname, __filename) {
        var $, x$;
        $ = require("/lib/dom/index.ls", module).$;
        x$ = $(".forum-options");
        x$.parentNode.removeChild(x$);
        $(".content-trail").appendChild(x$);
    });
    require.define("/src/forum-actions/index.ls", function(module, exports, __dirname, __filename) {
        var jumps, checkUpdates;
        jumps = require("/src/forum-actions/jumps/index.ls", module);
        checkUpdates = require("/src/forum-actions/check-updates.ls", module);
    });
    require.define("/src/forum-actions/check-updates.ls", function(module, exports, __dirname, __filename) {
        var lang, ajax, tbodyRegular, forum, ref$, $, node, firstTopicId, trHtml, aEndHtml, tbodyHtml, x$, h1, timeout, refresh;
        lang = require("/lib/lang/index.ls", module);
        ajax = require("/lib/ajax/index.ls", module);
        tbodyRegular = require("/src/tbody-regular.ls", module);
        forum = require("/src/forum.ls", module);
        ref$ = require("/lib/dom/index.ls", module), $ = ref$.$, node = ref$.node;
        firstTopicId = tbodyRegular.children[0].id.slice("postRow".length);
        trHtml = '<tr id="postRow' + firstTopicId;
        aEndHtml = 'data-tooltip-options=\'{"location": "mouse"}\'>';
        tbodyHtml = '<tbody class="regular">';
        x$ = $(".forum-actions-top");
        x$.insertBefore(h1 = node("h1"), (ref$ = x$.children)[ref$.length - 1]);
        timeout = 15..seconds();
        refresh = function() {
            return ajax.get(document.location, function() {
                var afterRegular, startPos, title;
                if (this.status !== 200) {
                    console.log("encountered status " + this.status + " while checking for updates; forum might be unstable");
                    return;
                }
                h1.innerHTML = lang.checkingNew;
                afterRegular = this.response.slice(tbodyHtml.length + this.response.indexOf(tbodyHtml)).trim();
                if (afterRegular.startsWith(trHtml)) {
                    h1.innerHTML += " <u>" + lang.noNew + "</u>";
                    setTimeout(function() {
                        return h1.innerHTML = "";
                    }, 1500);
                    setTimeout(refresh, timeout);
                } else {
                    startPos = aEndHtml.length + afterRegular.indexOf(aEndHtml);
                    afterRegular = afterRegular.slice(startPos);
                    title = afterRegular.to(afterRegular.indexOf("<")).trim();
                    h1.innerHTML = "<a href='" + document.location + "'>" + lang.newMessages + "</a> : " + [ title.length > 30 ? "<br />" : void 8 ] + title;
                }
            });
        };
        refresh === (ref$ = forum.dataset.page) && ref$ > 1;
    });
    require.define("/src/forum-actions/jumps/index.ls", function(module, exports, __dirname, __filename) {
        var newTopic, page;
        newTopic = require("/src/forum-actions/jumps/new-topic.ls", module);
        page = require("/src/forum-actions/jumps/page.ls", module);
    });
    require.define("/src/forum-actions/jumps/page.ls", function(module, exports, __dirname, __filename) {
        var bindKey, page;
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        page = require("/src/forum-actions/page.ls", module);
        bindKey("p", "jump-to-page", page);
    });
    require.define("/src/forum-actions/page.ls", function(module, exports, __dirname, __filename) {
        var lang, $$, jump, i$, x$, ref$, len$, join$ = [].join, slice$ = [].slice;
        lang = require("/lib/lang/index.ls", module);
        $$ = require("/lib/dom/index.ls", module).$$;
        module.exports = jump = function() {
            var page;
            page = prompt(lang("page-number"));
            if (+page + "" === page) {
                document.location = join$.call(slice$.call((document.location + "").split("/"), 0, -1), "/") + ("/?page=" + (page > 1 ? page : 1));
            }
        };
        for (i$ = 0, len$ = (ref$ = $$(".forum-actions .expander")).length; i$ < len$; ++i$) {
            x$ = ref$[i$];
            x$.onclick = jump;
        }
    });
    require.define("/src/forum-actions/jumps/new-topic.ls", function(module, exports, __dirname, __filename) {
        var bindKey, $;
        bindKey = require("/src/cheatsheet/bind-key.ls", module);
        $ = require("/lib/dom/index.ls", module).$;
        if (!$("a.button1.disabled")) {
            bindKey("n", "new-topic", function() {
                document.location += "topic";
            });
        }
    });
    require("/src/wowboardhelpers.ls");
}).call(this, this);